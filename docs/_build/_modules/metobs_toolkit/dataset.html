
<!DOCTYPE html>


<html lang="en" data-content_root="../../" >

  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>metobs_toolkit.dataset &#8212; metobs_toolkit 0.1.3a documentation</title>



  <script data-cfasync="false">
    document.documentElement.dataset.mode = localStorage.getItem("mode") || "";
    document.documentElement.dataset.theme = localStorage.getItem("theme") || "light";
  </script>

  <!-- Loaded before other Sphinx assets -->
  <link href="../../_static/styles/theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/bootstrap.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
<link href="../../_static/styles/pydata-sphinx-theme.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />


  <link href="../../_static/vendor/fontawesome/6.5.1/css/all.min.css?digest=8d27b9dea8ad943066ae" rel="stylesheet" />
  <link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-solid-900.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-brands-400.woff2" />
<link rel="preload" as="font" type="font/woff2" crossorigin href="../../_static/vendor/fontawesome/6.5.1/webfonts/fa-regular-400.woff2" />

    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=a746c00c" />
    <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
    <link rel="stylesheet" type="text/css" href="../../_static/custom.css?v=a7314d79" />

  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae" />
<link rel="preload" as="script" href="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae" />
  <script src="../../_static/vendor/fontawesome/6.5.1/js/all.min.js?digest=8d27b9dea8ad943066ae"></script>

    <script src="../../_static/jquery.js?v=5d32c60e"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
    <script src="../../_static/documentation_options.js?v=57d30286"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
    <script src="../../_static/copybutton.js?v=f281be69"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>DOCUMENTATION_OPTIONS.pagename = '_modules/metobs_toolkit/dataset';</script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="docsearch:language" content="en"/>
  </head>


  <body data-bs-spy="scroll" data-bs-target=".bd-toc-nav" data-offset="180" data-bs-root-margin="0px 0px -60%" data-default-mode="">



  <a id="pst-skip-link" class="skip-link" href="#main-content">Skip to main content</a>

  <div id="pst-scroll-pixel-helper"></div>

  <button type="button" class="btn rounded-pill" id="pst-back-to-top">
    <i class="fa-solid fa-arrow-up"></i>
    Back to top
  </button>


  <input type="checkbox"
          class="sidebar-toggle"
          name="__primary"
          id="__primary"/>
  <label class="overlay overlay-primary" for="__primary"></label>

  <input type="checkbox"
          class="sidebar-toggle"
          name="__secondary"
          id="__secondary"/>
  <label class="overlay overlay-secondary" for="__secondary"></label>

  <div class="search-button__wrapper">
    <div class="search-button__overlay"></div>
    <div class="search-button__search-container">
<form class="bd-search d-flex align-items-center"
      action="../../search.html"
      method="get">
  <i class="fa-solid fa-magnifying-glass"></i>
  <input type="search"
         class="form-control"
         name="q"
         id="search-input"
         placeholder="Search the docs ..."
         aria-label="Search the docs ..."
         autocomplete="off"
         autocorrect="off"
         autocapitalize="off"
         spellcheck="false"/>
  <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd>K</kbd></span>
</form></div>
  </div>

    <header class="bd-header navbar navbar-expand-lg bd-navbar">
<div class="bd-header__inner bd-page-width">
  <label class="sidebar-toggle primary-toggle" for="__primary">
    <span class="fa-solid fa-bars"></span>
  </label>


  <div class="col-lg-3 navbar-header-items__start">

      <div class="navbar-item">



<a class="navbar-brand logo" href="../../index.html">










    <img src="../../_static/logo_small.svg" class="logo__image only-light" alt="metobs_toolkit 0.1.3a documentation - Home"/>
    <script>document.write(`<img src="../../_static/logo_small.svg" class="logo__image only-dark" alt="metobs_toolkit 0.1.3a documentation - Home"/>`);</script>


</a></div>

  </div>

  <div class="col-lg-9 navbar-header-items">

    <div class="me-auto navbar-header-items__center">

        <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../index.html">
                        Home
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../intro.html">
                        Getting started
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../specific_topics.html">
                        Specific topics
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../examples/index.html">
                        Examples
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../MetObs_documentation_flat.html">
                        Documentation
                      </a>
                    </li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links">
                    More
                </button>
                <ul id="pst-nav-more-links" class="dropdown-menu">

                    <li class="nav-item">
                      <a class="nav-link dropdown-item nav-internal" href="../../topics/contributing_link.html">
                        Contributing
                      </a>
                    </li>

                </ul>
            </li>

  </ul>
</nav></div>

    </div>


    <div class="navbar-header-items__end">

        <div class="navbar-item navbar-persistent--container">


 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
        </div>


        <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>

        <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">








          <a href="https://github.com/vergauwenthomas/MetObs_toolkit" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fab fa-github-square fa-xl fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>

    </div>

  </div>


    <div class="navbar-persistent--mobile">

 <script>
 document.write(`
   <button class="btn navbar-btn search-button-field search-button__button" title="Search" aria-label="Search" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <i class="fa-solid fa-magnifying-glass"></i>
    <span class="search-button__default-text">Search</span>
    <span class="search-button__kbd-shortcut"><kbd class="kbd-shortcut__modifier">Ctrl</kbd>+<kbd class="kbd-shortcut__modifier">K</kbd></span>
   </button>
 `);
 </script>
    </div>



</div>

    </header>


  <div class="bd-container">
    <div class="bd-container__inner bd-page-width">





      <div class="bd-sidebar-primary bd-sidebar hide-on-wide">



  <div class="sidebar-header-items sidebar-primary__section">


      <div class="sidebar-header-items__center">

          <div class="navbar-item">
<nav class="navbar-nav">
  <ul class="bd-navbar-elements navbar-nav">

                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../index.html">
                        Home
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../intro.html">
                        Getting started
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../specific_topics.html">
                        Specific topics
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../examples/index.html">
                        Examples
                      </a>
                    </li>


                    <li class="nav-item">
                      <a class="nav-link nav-internal" href="../../MetObs_documentation_flat.html">
                        Documentation
                      </a>
                    </li>

            <li class="nav-item dropdown">
                <button class="btn dropdown-toggle nav-item" type="button" data-bs-toggle="dropdown" aria-expanded="false" aria-controls="pst-nav-more-links-2">
                    More
                </button>
                <ul id="pst-nav-more-links-2" class="dropdown-menu">

                    <li class="nav-item">
                      <a class="nav-link dropdown-item nav-internal" href="../../topics/contributing_link.html">
                        Contributing
                      </a>
                    </li>

                </ul>
            </li>

  </ul>
</nav></div>

      </div>



      <div class="sidebar-header-items__end">

          <div class="navbar-item">

<script>
document.write(`
  <button class="btn btn-sm navbar-btn theme-switch-button" title="light/dark" aria-label="light/dark" data-bs-placement="bottom" data-bs-toggle="tooltip">
    <span class="theme-switch nav-link" data-mode="light"><i class="fa-solid fa-sun fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="dark"><i class="fa-solid fa-moon fa-lg"></i></span>
    <span class="theme-switch nav-link" data-mode="auto"><i class="fa-solid fa-circle-half-stroke fa-lg"></i></span>
  </button>
`);
</script></div>

          <div class="navbar-item"><ul class="navbar-icon-links navbar-nav"
    aria-label="Icon Links">
        <li class="nav-item">








          <a href="https://github.com/vergauwenthomas/MetObs_toolkit" title="GitHub" class="nav-link" rel="noopener" target="_blank" data-bs-toggle="tooltip" data-bs-placement="bottom"><span><i class="fab fa-github-square fa-xl fa-lg" aria-hidden="true"></i></span>
            <span class="sr-only">GitHub</span></a>
        </li>
</ul></div>

      </div>

  </div>


  <div class="sidebar-primary-items__end sidebar-primary__section">
  </div>

  <div id="rtd-footer-container"></div>


      </div>

      <main id="main-content" class="bd-main">


          <div class="bd-content">
            <div class="bd-article-container">

              <div class="bd-header-article">
<div class="header-article-items header-article__inner">

    <div class="header-article-items__start">

        <div class="header-article-item">



<nav aria-label="Breadcrumb">
  <ul class="bd-breadcrumbs">

    <li class="breadcrumb-item breadcrumb-home">
      <a href="../../index.html" class="nav-link" aria-label="Home">
        <i class="fa-solid fa-home"></i>
      </a>
    </li>

    <li class="breadcrumb-item"><a href="../index.html" class="nav-link">Module code</a></li>

    <li class="breadcrumb-item active" aria-current="page">metobs_toolk...</li>
  </ul>
</nav>
</div>

    </div>


</div>
</div>




<div id="searchbox"></div>
                <article class="bd-article">

  <h1>Source code for metobs_toolkit.dataset</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python3</span>
<span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">This module contains the Dataset class and all its methods.</span>

<span class="sd">A Dataset holds all observations and is at the center of the</span>
<span class="sd">MetObs-toolkit.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">timedelta</span>
<span class="kn">import</span> <span class="nn">pytz</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pickle</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.settings</span> <span class="kn">import</span> <span class="n">Settings</span>
<span class="kn">from</span> <span class="nn">metobs_toolkit.data_import</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">import_data_from_csv</span><span class="p">,</span>
    <span class="n">import_metadata_from_csv</span><span class="p">,</span>
    <span class="n">read_csv_template</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.printing</span> <span class="kn">import</span> <span class="n">print_dataset_info</span>
<span class="kn">from</span> <span class="nn">metobs_toolkit.landcover_functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">connect_to_gee</span><span class="p">,</span>
    <span class="n">lcz_extractor</span><span class="p">,</span>
    <span class="n">height_extractor</span><span class="p">,</span>
    <span class="n">lc_fractions_extractor</span><span class="p">,</span>
    <span class="n">_validate_metadf</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.plotting_functions</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">geospatial_plot</span><span class="p">,</span>
    <span class="n">timeseries_plot</span><span class="p">,</span>
    <span class="n">qc_stats_pie</span><span class="p">,</span>
    <span class="n">folium_plot</span><span class="p">,</span>
    <span class="n">add_stations_to_folium_map</span><span class="p">,</span>
    <span class="n">make_folium_html_plot</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.qc_checks</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">gross_value_check</span><span class="p">,</span>
    <span class="n">persistance_check</span><span class="p">,</span>
    <span class="n">repetitions_check</span><span class="p">,</span>
    <span class="n">duplicate_timestamp_check</span><span class="p">,</span>
    <span class="n">step_check</span><span class="p">,</span>
    <span class="n">window_variation_check</span><span class="p">,</span>
    <span class="n">invalid_input_check</span><span class="p">,</span>
    <span class="n">toolkit_buddy_check</span><span class="p">,</span>
    <span class="n">titan_buddy_check</span><span class="p">,</span>
    <span class="n">titan_sct_resistant_check</span><span class="p">,</span>
<span class="p">)</span>


<span class="kn">from</span> <span class="nn">metobs_toolkit.qc_statistics</span> <span class="kn">import</span> <span class="n">get_freq_statistics</span>
<span class="kn">from</span> <span class="nn">metobs_toolkit.writing_files</span> <span class="kn">import</span> <span class="n">write_dataset_to_csv</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.missingobs</span> <span class="kn">import</span> <span class="n">Missingob_collection</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.gap</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">Gap</span><span class="p">,</span>
    <span class="n">remove_gaps_from_obs</span><span class="p">,</span>
    <span class="n">remove_gaps_from_outliers</span><span class="p">,</span>
    <span class="n">missing_timestamp_and_gap_check</span><span class="p">,</span>
    <span class="n">get_gaps_indx_in_obs_space</span><span class="p">,</span>
    <span class="n">get_station_gaps</span><span class="p">,</span>
    <span class="n">apply_interpolate_gaps</span><span class="p">,</span>
    <span class="n">make_gapfill_df</span><span class="p">,</span>
    <span class="n">apply_debias_era5_gapfill</span><span class="p">,</span>
    <span class="n">gaps_to_df</span><span class="p">,</span>
<span class="p">)</span>


<span class="kn">from</span> <span class="nn">metobs_toolkit.df_helpers</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">multiindexdf_datetime_subsetting</span><span class="p">,</span>
    <span class="n">fmt_datetime_argument</span><span class="p">,</span>
    <span class="n">init_multiindex</span><span class="p">,</span>
    <span class="n">init_multiindexdf</span><span class="p">,</span>
    <span class="n">init_triple_multiindexdf</span><span class="p">,</span>
    <span class="n">metadf_to_gdf</span><span class="p">,</span>
    <span class="n">conv_applied_qc_to_df</span><span class="p">,</span>
    <span class="n">get_freqency_series</span><span class="p">,</span>
    <span class="n">value_labeled_doubleidxdf_to_triple_idxdf</span><span class="p">,</span>
    <span class="n">xs_save</span><span class="p">,</span>
    <span class="n">concat_save</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">metobs_toolkit.obstypes</span> <span class="kn">import</span> <span class="n">tlk_obstypes</span>
<span class="kn">from</span> <span class="nn">metobs_toolkit.obstypes</span> <span class="kn">import</span> <span class="n">Obstype</span> <span class="k">as</span> <span class="n">Obstype_class</span>


<span class="kn">from</span> <span class="nn">metobs_toolkit.analysis</span> <span class="kn">import</span> <span class="n">Analysis</span>
<span class="kn">from</span> <span class="nn">metobs_toolkit.modeldata</span> <span class="kn">import</span> <span class="n">Modeldata</span>


<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># =============================================================================</span>
<span class="c1"># Dataset class</span>
<span class="c1"># =============================================================================</span>


<span class="k">class</span> <span class="nc">Dataset</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Objects holding observations and methods on observations.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="Dataset.__init__">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.html#metobs_toolkit.Dataset.__init__">[docs]</a>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct all the necessary attributes for Dataset object.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Initialise dataset&quot;</span><span class="p">)</span>

        <span class="c1"># Dataset with &#39;good&#39; observations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># Dataset with outlier observations</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">init_triple_multiindexdf</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># becomes a Missingob_collection after import</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># becomes a list of gaps</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span> <span class="o">=</span> <span class="n">init_multiindexdf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_fill_df</span> <span class="o">=</span> <span class="n">init_multiindexdf</span><span class="p">()</span>

        <span class="c1"># Dataset with metadata (static)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># dictionary storing present observationtypes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span> <span class="o">=</span> <span class="n">tlk_obstypes</span>  <span class="c1"># init with all tlk obstypes</span>

        <span class="c1"># dataframe containing all information on the description and mapping</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_istype</span> <span class="o">=</span> <span class="s2">&quot;Dataset&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_freqs</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">,</span> <span class="s2">&quot;checkname&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qc_checked_obstypes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list with qc-checked obstypes</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">Settings</span><span class="p">())</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Represent as text.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_istype</span> <span class="o">==</span> <span class="s2">&quot;Dataset&quot;</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;Empty instance of a Dataset.&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s2">&quot;Empty instance of a Station.&quot;</span>
        <span class="n">add_info</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">n_stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_obs_tot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">n_outl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">startdt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">enddt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">())</span> <span class="o">&amp;</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="p">):</span>
            <span class="n">add_info</span> <span class="o">+=</span> <span class="s2">&quot;    *Coordinates are available for all stations. </span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Dataset instance containing: </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="n">n_stations</span><span class="si">}</span><span class="s2"> stations </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span><span class="si">}</span><span class="s2"> observation types </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="n">n_obs_tot</span><span class="si">}</span><span class="s2"> observation records </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="n">n_outl</span><span class="si">}</span><span class="s2"> records labeled as outliers </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">)</span><span class="si">}</span><span class="s2"> gaps </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">series</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> missing observations </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *records range: </span><span class="si">{</span><span class="n">startdt</span><span class="si">}</span><span class="s2"> --&gt; </span><span class="si">{</span><span class="n">enddt</span><span class="si">}</span><span class="s2"> (total duration:  </span><span class="si">{</span><span class="n">enddt</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">startdt</span><span class="si">}</span><span class="s2">) </span><span class="se">\n</span><span class="s2"> </span><span class="se">\</span>
<span class="s2">    *time zone of the records: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s1">&#39;timezone&#39;</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="se">\n</span><span class="s2"> &quot;</span>
            <span class="o">+</span> <span class="n">add_info</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Info representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__str__</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">gapsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Addition of two Datasets.&quot;&quot;&quot;</span>
        <span class="c1"># important !!!!!</span>

        <span class="c1"># the toolkit makes a new dataframe, and assumes the df from self and other</span>
        <span class="c1"># to be the input data.</span>
        <span class="c1"># This means that missing obs, gaps, invalid and duplicated records are</span>
        <span class="c1"># being looked for in the concatenation of both dataset, using their current</span>
        <span class="c1"># resolution !</span>

        <span class="n">new</span> <span class="o">=</span> <span class="n">Dataset</span><span class="p">()</span>
        <span class="n">self_obstypes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1">#  ---- df ----</span>

        <span class="c1"># check if observation of self are also in other</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">([(</span><span class="n">obs</span> <span class="ow">in</span> <span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="n">self_obstypes</span><span class="p">])</span>
        <span class="c1"># subset obstype of other to self</span>
        <span class="n">other</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">to_list</span><span class="p">()]</span>

        <span class="c1"># remove duplicate rows</span>
        <span class="n">common_indexes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
        <span class="n">other</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">common_indexes</span><span class="p">)</span>

        <span class="c1"># set new df</span>
        <span class="n">new</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="p">])</span>
        <span class="n">new</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="c1">#  ----- outliers df ---------</span>

        <span class="n">other_outliers</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
        <span class="n">other_outliers</span> <span class="o">=</span> <span class="n">other_outliers</span><span class="p">[</span><span class="n">other_outliers</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">self_obstypes</span><span class="p">)]</span>
        <span class="n">other_outliers</span> <span class="o">=</span> <span class="n">other_outliers</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;obstype&quot;</span><span class="p">])</span>
        <span class="n">new</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">other_outliers</span><span class="p">])</span>
        <span class="n">new</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="c1">#  ------- Gaps -------------</span>
        <span class="c1"># Gaps have to be recaluculated using a frequency assumtion from the</span>
        <span class="c1"># combination of self.df and other.df, thus NOT the native frequency if</span>
        <span class="c1"># their is a coarsening allied on either of them.</span>
        <span class="n">new</span><span class="o">.</span><span class="n">gaps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># ---------- missing ---------</span>
        <span class="c1"># Missing observations have to be recaluculated using a frequency assumtion from the</span>
        <span class="c1"># combination of self.df and other.df, thus NOT the native frequency if</span>
        <span class="c1"># their is a coarsening allied on either of them.</span>
        <span class="n">new</span><span class="o">.</span><span class="n">missing_obs</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># ---------- metadf -----------</span>
        <span class="c1"># Use the metadf from self and add new rows if they are present in other</span>
        <span class="n">new</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">metadf</span><span class="p">])</span>
        <span class="n">new</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop_duplicates</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="c1"># ------- specific attributes ----------</span>

        <span class="c1"># Template (units and descritpions) are taken from self</span>
        <span class="n">new</span><span class="o">.</span><span class="n">data_template</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span>

        <span class="c1"># Inherit Settings from self</span>
        <span class="n">new</span><span class="o">.</span><span class="n">settings</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">)</span>

        <span class="c1"># Applied qc:</span>
        <span class="c1"># TODO:  is this oke to do?</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">,</span> <span class="s2">&quot;checkname&quot;</span><span class="p">])</span>
        <span class="n">new</span><span class="o">.</span><span class="n">_qc_checked_obstypes</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list with qc-checked obstypes</span>

        <span class="c1"># set init_dataframe to empty</span>
        <span class="c1"># NOTE: this is not necesarry but users will use this method when they</span>
        <span class="c1"># have a datafile that is to big. So storing and overloading a copy of</span>
        <span class="c1"># the very big datafile is invalid for these cases.</span>
        <span class="n">new</span><span class="o">.</span><span class="n">input_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>

        <span class="c1"># ----- Apply IO QC ---------</span>
        <span class="c1"># Apply only checks that are relevant on records in between self and other</span>
        <span class="c1"># OR</span>
        <span class="c1"># that are dependand on the frequency (since the freq of the .df is used,</span>
        <span class="c1"># which is not the naitive frequency if coarsening is applied on either. )</span>

        <span class="c1"># missing and gap check</span>
        <span class="k">if</span> <span class="n">gapsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">gapsize</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_settings&quot;</span><span class="p">][</span><span class="s2">&quot;gaps_finder&quot;</span><span class="p">][</span><span class="s2">&quot;gapsize_n&quot;</span><span class="p">]</span>

        <span class="c1"># note gapsize is now defined on the frequency of self</span>
        <span class="n">new</span><span class="o">.</span><span class="n">missing_obs</span><span class="p">,</span> <span class="n">new</span><span class="o">.</span><span class="n">gaps</span> <span class="o">=</span> <span class="n">missing_timestamp_and_gap_check</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">new</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">gapsize_n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_settings&quot;</span><span class="p">][</span><span class="s2">&quot;gaps_finder&quot;</span><span class="p">][</span><span class="s2">&quot;gapsize_n&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># duplicate check</span>
        <span class="n">new</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">dup_outl_df</span> <span class="o">=</span> <span class="n">duplicate_timestamp_check</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">new</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">checks_info</span><span class="o">=</span><span class="n">new</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
            <span class="n">checks_settings</span><span class="o">=</span><span class="n">new</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">dup_outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="n">new</span><span class="o">.</span><span class="n">update_outliersdf</span><span class="p">(</span><span class="n">add_to_outliersdf</span><span class="o">=</span><span class="n">dup_outl_df</span><span class="p">)</span>

        <span class="c1"># update the order and which qc is applied on which obstype</span>
        <span class="n">checked_obstypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

        <span class="n">checknames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;duplicated_timestamp&quot;</span><span class="p">]</span>  <span class="c1"># KEEP order</span>

        <span class="n">new</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">new</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                    <span class="n">obstypes</span><span class="o">=</span><span class="n">checked_obstypes</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="n">checknames</span>
                <span class="p">),</span>
            <span class="p">],</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">new</span>

<div class="viewcode-block" id="Dataset.show">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.show.html#metobs_toolkit.Dataset.show">[docs]</a>
    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_all_settings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_disp_n_gaps</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show detailed information of the Dataset.</span>

<span class="sd">        A function to print out a detailed overview information about the Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show_all_settings : bool, optional</span>
<span class="sd">            If True all the settings are printed out. The default is False.</span>
<span class="sd">        max_disp_n_gaps: int, optional</span>
<span class="sd">            The maximum number of gaps to display detailed information of.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Show basic info of dataset.&quot;</span><span class="p">)</span>

        <span class="n">print_dataset_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_all_settings</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.get_info">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_info.html#metobs_toolkit.Dataset.get_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">show_all_settings</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">max_disp_n_gaps</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Alias of show().</span>

<span class="sd">        A function to print out a detailed overview information about the Dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        show_all_settings : bool, optional</span>
<span class="sd">            If True all the settings are printed out. The default is False.</span>
<span class="sd">        max_disp_n_gaps: int, optional</span>
<span class="sd">            The maximum number of gaps to display detailed information of.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">show_all_settings</span><span class="p">,</span> <span class="n">max_disp_n_gaps</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.save_dataset">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.save_dataset.html#metobs_toolkit.Dataset.save_dataset">[docs]</a>
    <span class="k">def</span> <span class="nf">save_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outputfolder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;saved_dataset.pkl&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Save a Dataset instance to a (pickle) file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        outputfolder : str or None, optional</span>
<span class="sd">            The path to the folder to save the file. If None, the outputfolder</span>
<span class="sd">            from the Settings is used. The default is None.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the output file. The default is &#39;saved_dataset.pkl&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if outputfolder is known and exists</span>
        <span class="k">if</span> <span class="n">outputfolder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">outputfolder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">outputfolder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;No outputfolder is given, and no outputfolder is found in the settings.&quot;</span>

        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">outputfolder</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">outputfolder</span><span class="si">}</span><span class="s2"> is not a directory!&quot;</span>

        <span class="c1"># check file extension in the filename:</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span> <span class="o">!=</span> <span class="s2">&quot;.pkl&quot;</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">+=</span> <span class="s2">&quot;.pkl&quot;</span>

        <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">outputfolder</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># check if file exists</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s2"> is already a file!&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="s2">&quot;wb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outp</span><span class="p">:</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">pickle</span><span class="o">.</span><span class="n">HIGHEST_PROTOCOL</span><span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset saved in </span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dataset saved in </span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.import_dataset">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.import_dataset.html#metobs_toolkit.Dataset.import_dataset">[docs]</a>
    <span class="k">def</span> <span class="nf">import_dataset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">folder_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="s2">&quot;saved_dataset.pkl&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Import a Dataset instance from a (pickle) file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        folder_path : str or None, optional</span>
<span class="sd">            The path to the folder to save the file. If None, the outputfolder</span>
<span class="sd">            from the Settings is used. The default is None.</span>
<span class="sd">        filename : str, optional</span>
<span class="sd">            The name of the output file. The default is &#39;saved_dataset.pkl&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metobs_toolkit.Dataset</span>
<span class="sd">            The Dataset instance.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if folder_path is known and exists</span>
        <span class="k">if</span> <span class="n">folder_path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">folder_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">folder_path</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
            <span class="p">),</span> <span class="s2">&quot;No folder_path is given, and no outputfolder is found in the settings.&quot;</span>

        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">folder_path</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">folder_path</span><span class="si">}</span><span class="s2"> is not a directory!&quot;</span>

        <span class="n">full_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">folder_path</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span>

        <span class="c1"># check if file exists</span>
        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">full_path</span><span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">full_path</span><span class="si">}</span><span class="s2"> does not exist.&quot;</span>

        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">inp</span><span class="p">:</span>
            <span class="n">dataset</span> <span class="o">=</span> <span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="c1"># convert metadf to a geodataframe (if coordinates are available)</span>
        <span class="n">dataset</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">metadf_to_gdf</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">metadf</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dataset</span></div>


<div class="viewcode-block" id="Dataset.add_new_observationtype">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.add_new_observationtype.html#metobs_toolkit.Dataset.add_new_observationtype">[docs]</a>
    <span class="k">def</span> <span class="nf">add_new_observationtype</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Obstype</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a new observation type to the known observation types.</span>

<span class="sd">        The observation can only be added if it is not already present in the</span>
<span class="sd">        knonw observation types. If that is the case that you probably need to</span>
<span class="sd">        use use the Dataset.add_new_unit() method.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Obstype : metobs_toolkit.obstype.Obstype</span>
<span class="sd">            The new Obstype to add.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Test if the obstype is of the correct class.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">Obstype</span><span class="p">,</span> <span class="n">Obstype_class</span><span class="p">):</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Obstype</span><span class="si">}</span><span class="s2"> is not an instance of metobs_toolkit.obstypes.Obstype.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Test if the obsname is already in use</span>
        <span class="k">if</span> <span class="n">Obstype</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">Obstype</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is already a known observation type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">Obstype</span><span class="o">.</span><span class="n">name</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># Update the known obstypes</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Adding </span><span class="si">{</span><span class="n">Obstype</span><span class="si">}</span><span class="s2"> to the list of knonw observation types.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">Obstype</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">Obstype</span></div>


<div class="viewcode-block" id="Dataset.add_new_unit">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.add_new_unit.html#metobs_toolkit.Dataset.add_new_unit">[docs]</a>
    <span class="k">def</span> <span class="nf">add_new_unit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">new_unit</span><span class="p">,</span> <span class="n">conversion_expression</span><span class="o">=</span><span class="p">[]):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add a new unit to a known observation type.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : str</span>
<span class="sd">            The observation type to add the new unit to.</span>
<span class="sd">        new_unit : str</span>
<span class="sd">            The new unit name.</span>
<span class="sd">        conversion_expression : list or str, optional</span>
<span class="sd">            The conversion expression to the standard unit of the observation</span>
<span class="sd">            type. The expression is a (list of) strings with simple algebraic</span>
<span class="sd">            operations, where x represent the value in the new unit, and the</span>
<span class="sd">            result is the value in the standard unit. Two examples for</span>
<span class="sd">            temperature (with a standard unit in Celcius):</span>

<span class="sd">                [&quot;x - 273.15&quot;] #if the new_unit is Kelvin</span>
<span class="sd">                [&quot;x-32.0&quot;, &quot;x/1.8&quot;] #if the new unit is Farenheit</span>

<span class="sd">            The default is [].</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># test if observation is present</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">obstype</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> is not a known obstype! No unit can be added.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># check if the unit is already present</span>
        <span class="n">is_present</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">test_if_unit_is_known</span><span class="p">(</span><span class="n">new_unit</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_present</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">new_unit</span><span class="si">}</span><span class="s2"> is already a known unit of </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">add_unit</span><span class="p">(</span>
            <span class="n">unit_name</span><span class="o">=</span><span class="n">new_unit</span><span class="p">,</span> <span class="n">conversion</span><span class="o">=</span><span class="n">conversion_expression</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.show_settings">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.show_settings.html#metobs_toolkit.Dataset.show_settings">[docs]</a>
    <span class="k">def</span> <span class="nf">show_settings</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Show detailed information of the stored Settings.</span>

<span class="sd">        A function that prints out all the settings, structured per thematic.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>


<div class="viewcode-block" id="Dataset.get_station">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_station.html#metobs_toolkit.Dataset.get_station">[docs]</a>
    <span class="k">def</span> <span class="nf">get_station</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stationname</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Filter out one station of the Dataset.</span>

<span class="sd">        Extract a metobs_toolkit.Station object from the dataset by name.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        stationname : string</span>
<span class="sd">            The name of the station.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metobs_toolkit.Station</span>
<span class="sd">            The station object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">metobs_toolkit.station</span> <span class="kn">import</span> <span class="n">Station</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Extract </span><span class="si">{</span><span class="n">stationname</span><span class="si">}</span><span class="s2"> from dataset.&quot;</span><span class="p">)</span>

        <span class="c1"># important: make shure all station attributes are of the same time as dataset.</span>
        <span class="c1"># so that all methods can be inherited.</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">sta_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">stationname</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">sta_metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stationname</span><span class="p">]</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
            <span class="n">sta_metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;name&quot;</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">stationname</span><span class="si">}</span><span class="s2"> not found in the dataset.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">sta_outliers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span>
                <span class="n">stationname</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">sta_outliers</span> <span class="o">=</span> <span class="n">init_triple_multiindexdf</span><span class="p">()</span>

        <span class="n">sta_gaps</span> <span class="o">=</span> <span class="n">get_station_gaps</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">,</span> <span class="n">stationname</span><span class="p">)</span>
        <span class="n">sta_missingobs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">get_station_missingobs</span><span class="p">(</span><span class="n">stationname</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">sta_gapfill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span><span class="n">stationname</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">sta_gapfill</span> <span class="o">=</span> <span class="n">init_multiindexdf</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">sta_missingfill</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_fill_df</span><span class="o">.</span><span class="n">xs</span><span class="p">(</span>
                <span class="n">stationname</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">False</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">sta_missingfill</span> <span class="o">=</span> <span class="n">init_multiindexdf</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Station</span><span class="p">(</span>
            <span class="n">name</span><span class="o">=</span><span class="n">stationname</span><span class="p">,</span>
            <span class="n">df</span><span class="o">=</span><span class="n">sta_df</span><span class="p">,</span>
            <span class="n">outliersdf</span><span class="o">=</span><span class="n">sta_outliers</span><span class="p">,</span>
            <span class="n">gaps</span><span class="o">=</span><span class="n">sta_gaps</span><span class="p">,</span>
            <span class="n">missing_obs</span><span class="o">=</span><span class="n">sta_missingobs</span><span class="p">,</span>
            <span class="n">gapfilldf</span><span class="o">=</span><span class="n">sta_gapfill</span><span class="p">,</span>
            <span class="n">missing_fill_df</span><span class="o">=</span><span class="n">sta_missingfill</span><span class="p">,</span>
            <span class="n">metadf</span><span class="o">=</span><span class="n">sta_metadf</span><span class="p">,</span>
            <span class="n">obstypes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">,</span>
            <span class="n">data_template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">,</span>
            <span class="n">settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="n">_qc_checked_obstypes</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_qc_checked_obstypes</span><span class="p">,</span>
            <span class="n">_applied_qc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.make_plot">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.make_plot.html#metobs_toolkit.Dataset.make_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">make_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">stationnames</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">colorby</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">y_label</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">show_filled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_ax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>  <span class="c1"># needed for GUI, not recommended use</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function creates a timeseries plot for the dataset. The variable observation type</span>
<span class="sd">        is plotted for all stationnames from a starttime to an endtime.</span>

<span class="sd">        All styling attributes are extracted from the Settings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>

<span class="sd">        stationnames : list, optional</span>
<span class="sd">            A list with stationnames to include in the timeseries. If None is given, all the stations are used, defaults to None.</span>
<span class="sd">        obstype : string, optional</span>
<span class="sd">             Fieldname to visualise. This can be an observation or station</span>
<span class="sd">             attribute. The default is &#39;temp&#39;.</span>
<span class="sd">        colorby : &#39;label&#39; or &#39;name&#39;, optional</span>
<span class="sd">             Indicate how colors should be assigned to the lines. &#39;label&#39; will color the lines by their quality control label. &#39;name&#39; will color by each station, defaults to &#39;name&#39;.</span>
<span class="sd">        starttime : datetime.datetime, optional</span>
<span class="sd">             Specifiy the start datetime for the plot. If None is given it will use the start datetime of the dataset, defaults to None.</span>
<span class="sd">        endtime : datetime.datetime, optional</span>
<span class="sd">             Specifiy the end datetime for the plot. If None is given it will use the end datetime of the dataset, defaults to None.</span>
<span class="sd">        title : string, optional</span>
<span class="sd">             Title of the figure, if None a default title is generated. The default is None.</span>
<span class="sd">        y_label : string, optional</span>
<span class="sd">             y-axes label of the figure, if None a default label is generated. The default is None.</span>
<span class="sd">        legend : bool, optional</span>
<span class="sd">             If True, a legend is added to the plot. The default is True.</span>
<span class="sd">        show_outliers : bool, optional</span>
<span class="sd">             If true the observations labeld as outliers will be included in</span>
<span class="sd">             the plot. This is only true when colorby == &#39;name&#39;. The default</span>
<span class="sd">             is True.</span>
<span class="sd">        show_filled : bool, optional</span>
<span class="sd">             If true the filled values for gaps and missing observations will</span>
<span class="sd">             be included in the plot. This is only true when colorby == &#39;name&#39;.</span>
<span class="sd">             The default is True.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib.pyplot.axes</span>
<span class="sd">             The timeseries axes of the plot is returned.</span>

<span class="sd">        Note</span>
<span class="sd">        --------</span>
<span class="sd">        If a timezone unaware datetime is given as an argument, it is interpreted</span>
<span class="sd">        as if it has the same timezone as the observations.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">stationnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Make </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2">-timeseries plot for all stations&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Make </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2">-timeseries plot for </span><span class="si">{</span><span class="n">stationnames</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># combine all dataframes</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_all_to_obsspace</span><span class="p">()</span>

        <span class="c1"># subset to obstype</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="n">mergedf</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;obstype&quot;</span><span class="p">)</span>

        <span class="c1"># Subset on stationnames</span>
        <span class="k">if</span> <span class="n">stationnames</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="n">mergedf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">stationnames</span><span class="p">)]</span>

        <span class="c1"># Subset on start and endtime</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
            <span class="n">starttime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
            <span class="n">endtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">mergedf</span> <span class="o">=</span> <span class="n">multiindexdf_datetime_subsetting</span><span class="p">(</span><span class="n">mergedf</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">)</span>

        <span class="c1"># Get plot styling attributes</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stationnames</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_istype</span> <span class="o">==</span> <span class="s2">&quot;Dataset&quot;</span><span class="p">:</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">get_orig_name</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; for all stations. &quot;</span>
                    <span class="p">)</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_istype</span> <span class="o">==</span> <span class="s2">&quot;Station&quot;</span><span class="p">:</span>
                    <span class="n">title</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">get_orig_name</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot; of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">get_orig_name</span><span class="p">()</span>
                    <span class="o">+</span> <span class="s2">&quot; for stations: &quot;</span>
                    <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">stationnames</span><span class="p">)</span>
                <span class="p">)</span>
        <span class="c1"># create y label</span>
        <span class="k">if</span> <span class="n">y_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">y_label</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">get_plot_y_label</span><span class="p">()</span>
        <span class="c1"># Make plot</span>
        <span class="n">ax</span><span class="p">,</span> <span class="n">_colmap</span> <span class="o">=</span> <span class="n">timeseries_plot</span><span class="p">(</span>
            <span class="n">mergedf</span><span class="o">=</span><span class="n">mergedf</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">ylabel</span><span class="o">=</span><span class="n">y_label</span><span class="p">,</span>
            <span class="n">colorby</span><span class="o">=</span><span class="n">colorby</span><span class="p">,</span>
            <span class="n">show_legend</span><span class="o">=</span><span class="n">legend</span><span class="p">,</span>
            <span class="n">show_outliers</span><span class="o">=</span><span class="n">show_outliers</span><span class="p">,</span>
            <span class="n">show_filled</span><span class="o">=</span><span class="n">show_filled</span><span class="p">,</span>
            <span class="n">settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="n">_ax</span><span class="o">=</span><span class="n">_ax</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">ax</span></div>


<div class="viewcode-block" id="Dataset.make_interactive_plot">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.make_interactive_plot.html#metobs_toolkit.Dataset.make_interactive_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">make_interactive_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">save</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">outputfile</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">starttime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">endtime</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">mpl_cmap_name</span><span class="o">=</span><span class="s2">&quot;viridis&quot;</span><span class="p">,</span>
        <span class="n">radius</span><span class="o">=</span><span class="mi">13</span><span class="p">,</span>
        <span class="n">fill_alpha</span><span class="o">=</span><span class="mf">0.6</span><span class="p">,</span>
        <span class="n">max_fps</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span>
        <span class="n">outlier_col</span><span class="o">=</span><span class="s2">&quot;red&quot;</span><span class="p">,</span>
        <span class="n">ok_col</span><span class="o">=</span><span class="s2">&quot;black&quot;</span><span class="p">,</span>
        <span class="n">gap_col</span><span class="o">=</span><span class="s2">&quot;orange&quot;</span><span class="p">,</span>
        <span class="n">fill_col</span><span class="o">=</span><span class="s2">&quot;yellow&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make interactive geospatial plot with time evolution.</span>

<span class="sd">        This function uses the folium package to make an interactive geospatial</span>
<span class="sd">        plot to illustrate the time evolution.</span>



<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : str or metobs_toolkit.Obstype, optional</span>
<span class="sd">            The observation type to plot. The default is &#39;temp&#39;.</span>
<span class="sd">        save : bool, optional</span>
<span class="sd">            If true, the figure will be saved as an html-file. The default is True.</span>
<span class="sd">        outputfile : str, optional</span>
<span class="sd">            The path of the output html-file. The figure will be saved here, if</span>
<span class="sd">            save is True. If outputfile is not given, and save is True, than</span>
<span class="sd">            the figure will be saved in the default outputfolder (if given).</span>
<span class="sd">            The default is None.</span>
<span class="sd">        starttime : datetime.datetime, optional</span>
<span class="sd">             Specifiy the start datetime for the plot. If None is given it will</span>
<span class="sd">             use the start datetime of the dataset, defaults to None.</span>
<span class="sd">        endtime : datetime.datetime, optional</span>
<span class="sd">             Specifiy the end datetime for the plot. If None is given it will</span>
<span class="sd">             use the end datetime of the dataset, defaults to None.</span>
<span class="sd">        vmin : numeric, optional</span>
<span class="sd">            The value corresponding with the minimum color. If None, the</span>
<span class="sd">            minimum of the presented observations is used. The default is None.</span>
<span class="sd">        vmax : numeric, optional</span>
<span class="sd">            The value corresponding with the maximum color. If None, the</span>
<span class="sd">            maximum of the presented observations is used. The default is None.</span>
<span class="sd">        mpl_cmap_name : str, optional</span>
<span class="sd">            The name of the matplotlib colormap to use. The default is &#39;viridis&#39;.</span>
<span class="sd">        radius : int, optional</span>
<span class="sd">            The radius (in pixels) of the scatters. The default is 13.</span>
<span class="sd">        fill_alpha : float ([0;1]), optional</span>
<span class="sd">            The alpha of the fill color for the scatters. The default is 0.6.</span>
<span class="sd">        max_fps : int (&gt;0), optional</span>
<span class="sd">            The maximum allowd frames per second for the time evolution. The</span>
<span class="sd">            default is 4.</span>
<span class="sd">        outlier_col : str, optional</span>
<span class="sd">            The edge color of the scatters to identify an outliers. The default is &#39;red&#39;.</span>
<span class="sd">        ok_col : str, optional</span>
<span class="sd">            The edge color of the scatters to identify an ok observation. The default is &#39;black&#39;.</span>
<span class="sd">        gap_col : str, optional</span>
<span class="sd">            The edge color of the scatters to identify an missing/gap</span>
<span class="sd">            observation. The default is &#39;orange&#39;.</span>
<span class="sd">        fill_col : str, optional</span>
<span class="sd">            The edge color of the scatters to identify a fillded observation.</span>
<span class="sd">            The default is &#39;yellow&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        m : folium.folium.map</span>
<span class="sd">            The interactive folium map.</span>

<span class="sd">        Note</span>
<span class="sd">        -------</span>
<span class="sd">        The figure will only appear when this is runned in notebooks. If you do</span>
<span class="sd">        not run this in a notebook, make shure to save the html file, and open it</span>
<span class="sd">        with a browser.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if obstype is known</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obstype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">obstype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> is not found in the knonw observation types: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">obstype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outputfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                        <span class="s2">&quot;No outputfile is given, and there is no default outputfolder specified.&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">outputfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">output_folder</span><span class="p">,</span> <span class="s2">&quot;interactive_figure.html&quot;</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if outputfile has .html extension</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outputfile</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.html&quot;</span><span class="p">):</span>
                    <span class="n">outputfile</span> <span class="o">=</span> <span class="n">outputfile</span> <span class="o">+</span> <span class="s2">&quot;.html&quot;</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;The .hmtl extension is added to the outputfile: </span><span class="si">{</span><span class="n">outputfile</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Check if the obstype is present in the data</span>
        <span class="k">if</span> <span class="n">obstype</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obstype</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> is not found in your the Dataset.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Check if geospatial data is available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stations without coordinates detected: </span><span class="si">{</span><span class="n">_sta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stations without coordinates detected: </span><span class="si">{</span><span class="n">_sta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># Construct dataframe</span>
        <span class="n">combdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_all_to_obsspace</span><span class="p">()</span>
        <span class="n">combdf</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="n">combdf</span><span class="p">,</span> <span class="n">obstype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;obstype&quot;</span><span class="p">)</span>
        <span class="c1"># Merge geospatial info</span>
        <span class="n">combgdf</span> <span class="o">=</span> <span class="n">combdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># Subset on start and endtime</span>
        <span class="n">starttime</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
            <span class="n">starttime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">endtime</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
            <span class="n">endtime</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">combgdf</span> <span class="o">=</span> <span class="n">multiindexdf_datetime_subsetting</span><span class="p">(</span><span class="n">combgdf</span><span class="p">,</span> <span class="n">starttime</span><span class="p">,</span> <span class="n">endtime</span><span class="p">)</span>
        <span class="n">combgdf</span> <span class="o">=</span> <span class="n">combgdf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="c1"># to gdf</span>
        <span class="n">combgdf</span> <span class="o">=</span> <span class="n">metadf_to_gdf</span><span class="p">(</span><span class="n">combgdf</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="mi">4326</span><span class="p">)</span>

        <span class="c1"># Make label color mapper</span>
        <span class="n">label_col_map</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Ok label</span>
        <span class="n">label_col_map</span><span class="p">[</span><span class="s2">&quot;ok&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ok_col</span>
        <span class="c1"># outlier labels</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">label_col_map</span><span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="s2">&quot;outlier_flag&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">outlier_col</span>

        <span class="c1"># missing labels (gaps and missing values)</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_info&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">label_col_map</span><span class="p">[</span><span class="n">val</span><span class="p">[</span><span class="s2">&quot;outlier_flag&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">gap_col</span>

        <span class="c1"># fill labels</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">missing_obs</span><span class="p">[</span><span class="s2">&quot;missing_obs_fill_info&quot;</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">label_col_map</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_col</span>
        <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_info&quot;</span><span class="p">][</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">label_col_map</span><span class="p">[</span><span class="n">val</span><span class="p">]</span> <span class="o">=</span> <span class="n">fill_col</span>

        <span class="c1"># make time estimation</span>
        <span class="n">est_seconds</span> <span class="o">=</span> <span class="n">combgdf</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mf">2411.5</span>  <span class="c1"># normal laptop</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;The figure will take approximatly (laptop) </span><span class="si">{</span><span class="s2">&quot;</span><span class="si">{:.1f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">est_seconds</span><span class="p">)</span><span class="si">}</span><span class="s1"> seconds to make.&#39;</span>
        <span class="p">)</span>

        <span class="c1"># Making the figure</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">make_folium_html_plot</span><span class="p">(</span>
            <span class="n">gdf</span><span class="o">=</span><span class="n">combgdf</span><span class="p">,</span>
            <span class="n">variable_column</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">,</span>
            <span class="n">var_display_name</span><span class="o">=</span><span class="n">obstype</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
            <span class="n">var_unit</span><span class="o">=</span><span class="n">obstype</span><span class="o">.</span><span class="n">get_standard_unit</span><span class="p">(),</span>
            <span class="n">label_column</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span>
            <span class="n">label_col_map</span><span class="o">=</span><span class="n">label_col_map</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
            <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
            <span class="n">fill_alpha</span><span class="o">=</span><span class="n">fill_alpha</span><span class="p">,</span>
            <span class="n">mpl_cmap_name</span><span class="o">=</span><span class="n">mpl_cmap_name</span><span class="p">,</span>
            <span class="n">max_fps</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">max_fps</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Saving the htlm figure at </span><span class="si">{</span><span class="n">outputfile</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">m</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">outputfile</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">m</span></div>


<div class="viewcode-block" id="Dataset.make_geo_plot">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.make_geo_plot.html#metobs_toolkit.Dataset.make_geo_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">make_geo_plot</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">variable</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">timeinstance</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">legend</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">vmin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">vmax</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">legend_title</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">boundbox</span><span class="o">=</span><span class="p">[],</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make geospatial plot.</span>

<span class="sd">        This functions creates a geospatial plot for a field</span>
<span class="sd">        (observations or attributes) of all stations.</span>

<span class="sd">        If the field is timedepending, than the timeinstance is used to plot</span>
<span class="sd">        the field status at that datetime.</span>

<span class="sd">        If the field is categorical than the leged will have categorical</span>
<span class="sd">        values, else a colorbar is used.</span>

<span class="sd">        All styling attributes are extracted from the Settings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        variable : string, optional</span>
<span class="sd">            Fieldname to visualise. This can be an observation type or station</span>
<span class="sd">            or &#39;lcz&#39;. The default is &#39;temp&#39;.</span>
<span class="sd">        title : string, optional</span>
<span class="sd">            Title of the figure, if None a default title is generated. The default is None.</span>
<span class="sd">        timeinstance : datetime.datetime, optional</span>
<span class="sd">            Datetime moment of the geospatial plot. If None, the first occuring (not Nan) record is used. The default is None.</span>
<span class="sd">        legend : bool, optional</span>
<span class="sd">            I True, a legend is added to the plot. The default is True.</span>
<span class="sd">        vmin : numeric, optional</span>
<span class="sd">            The value corresponding with the minimum color. If None, the minimum of the presented observations is used. The default is None.</span>
<span class="sd">        vmax : numeric, optional</span>
<span class="sd">            The value corresponding with the maximum color. If None, the maximum of the presented observations is used. The default is None.</span>
<span class="sd">        legend_title : string, optional</span>
<span class="sd">            Title of the legend, if None a default title is generated. The default is None.</span>
<span class="sd">        boundbox : [lon-west, lat-south, lon-east, lat-north], optional</span>
<span class="sd">            The boundbox to indicate the domain to plot. The elemenst are numeric.</span>
<span class="sd">            If the list is empty, a boundbox is created automatically. The default</span>
<span class="sd">            is [].</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib.pyplot.geoaxes</span>
<span class="sd">            The geoaxes of the plot is returned.</span>

<span class="sd">        Note</span>
<span class="sd">        --------</span>
<span class="sd">        If a timezone unaware datetime is given as an argument, it is interpreted</span>
<span class="sd">        as if it has the same timezone as the observations.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load default plot settings</span>
        <span class="c1"># default_settings=Settings.plot_settings[&#39;spatial_geo&#39;]</span>

        <span class="c1"># get first (Not Nan) timeinstance of the dataset if not given</span>
        <span class="n">timeinstance</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
            <span class="n">timeinstance</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">timeinstance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">timeinstance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;temp&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Make </span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2">-geo plot at </span><span class="si">{</span><span class="n">timeinstance</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># check coordinates if available</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stations without coordinates detected: </span><span class="si">{</span><span class="n">_sta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stations without coordinates detected: </span><span class="si">{</span><span class="n">_sta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">boundbox</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">boundbox</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The boundbox (</span><span class="si">{</span><span class="n">boundbox</span><span class="si">}</span><span class="s2">) does not contain 4 elements! The default boundbox is used!&quot;</span>
                <span class="p">)</span>
                <span class="n">boundbox</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Check if LCZ if available</span>
        <span class="k">if</span> <span class="n">variable</span> <span class="o">==</span> <span class="s2">&quot;lcz&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lcz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">_sta</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lcz&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()][</span><span class="s2">&quot;lcz&quot;</span><span class="p">]</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Stations without lcz detected: </span><span class="si">{</span><span class="n">_sta</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Local climate zones at </span><span class="si">{</span><span class="n">timeinstance</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="n">legend_title</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># subset to timeinstance</span>
        <span class="n">plotdf</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">timeinstance</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span>

        <span class="c1"># merge metadata</span>
        <span class="n">plotdf</span> <span class="o">=</span> <span class="n">plotdf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>

        <span class="c1"># titles</span>
        <span class="k">if</span> <span class="n">title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">get_orig_name</span><span class="p">()</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">timeinstance</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">variable</span><span class="si">}</span><span class="s2"> at </span><span class="si">{</span><span class="n">timeinstance</span><span class="si">}</span><span class="s2">.&quot;</span>

        <span class="k">if</span> <span class="n">legend</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">legend_title</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">legend_title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">variable</span><span class="p">]</span><span class="o">.</span><span class="n">get_standard_unit</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="n">axis</span> <span class="o">=</span> <span class="n">geospatial_plot</span><span class="p">(</span>
            <span class="n">plotdf</span><span class="o">=</span><span class="n">plotdf</span><span class="p">,</span>
            <span class="n">variable</span><span class="o">=</span><span class="n">variable</span><span class="p">,</span>
            <span class="n">timeinstance</span><span class="o">=</span><span class="n">timeinstance</span><span class="p">,</span>
            <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="n">legend</span><span class="o">=</span><span class="n">legend</span><span class="p">,</span>
            <span class="n">legend_title</span><span class="o">=</span><span class="n">legend_title</span><span class="p">,</span>
            <span class="n">vmin</span><span class="o">=</span><span class="n">vmin</span><span class="p">,</span>
            <span class="n">vmax</span><span class="o">=</span><span class="n">vmax</span><span class="p">,</span>
            <span class="n">plotsettings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;plot_settings&quot;</span><span class="p">],</span>
            <span class="n">categorical_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;categorical_fields&quot;</span><span class="p">],</span>
            <span class="n">static_fields</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;static_fields&quot;</span><span class="p">],</span>
            <span class="n">display_name_mapper</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;display_name_mapper&quot;</span><span class="p">],</span>
            <span class="n">data_template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">,</span>
            <span class="n">boundbox</span><span class="o">=</span><span class="n">boundbox</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">axis</span></div>


    <span class="c1"># =============================================================================</span>
    <span class="c1">#   Gap Filling</span>
    <span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="Dataset.get_modeldata">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_modeldata.html#metobs_toolkit.Dataset.get_modeldata">[docs]</a>
    <span class="k">def</span> <span class="nf">get_modeldata</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">modelname</span><span class="o">=</span><span class="s2">&quot;ERA5_hourly&quot;</span><span class="p">,</span>
        <span class="n">modeldata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">stations</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">startdt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">enddt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make Modeldata for the Dataset.</span>

<span class="sd">        Make a metobs_toolkit.Modeldata object with modeldata at the locations</span>
<span class="sd">        of the stations present in the dataset.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modelname : str, optional</span>
<span class="sd">            Which dataset to download timeseries from. This is only used when</span>
<span class="sd">            no modeldata is provided. The default is &#39;ERA5_hourly&#39;.</span>
<span class="sd">        modeldata : metobs_toolkit.Modeldata, optional</span>
<span class="sd">            Use the modelname attribute and the gee information stored in the</span>
<span class="sd">            modeldata instance to extract timeseries.</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">            Name of the observationtype you want to apply gap filling on. The</span>
<span class="sd">            modeldata must contain this observation type as well. The</span>
<span class="sd">            default is &#39;temp&#39;.</span>
<span class="sd">        stations : string or list of strings, optional</span>
<span class="sd">            Stationnames to subset the modeldata to. If None, all stations will be used. The default is None.</span>
<span class="sd">        startdt : datetime.datetime, optional</span>
<span class="sd">            Start datetime of the model timeseries. If None, the start datetime of the dataset is used. The default is None.</span>
<span class="sd">        enddt : datetime.datetime, optional</span>
<span class="sd">            End datetime of the model timeseries. If None, the last datetime of the dataset is used. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Modl : metobs_toolkit.Modeldata</span>
<span class="sd">            The extracted modeldata for period and a set of stations.</span>

<span class="sd">        Note</span>
<span class="sd">        --------</span>
<span class="sd">        If a timezone unaware datetime is given as an argument, it is interpreted</span>
<span class="sd">        as if it has the same timezone as the observations.</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        When extracting large amounts of data, the timeseries data will be</span>
<span class="sd">        writen to a file and saved on your google drive. In this case, you need</span>
<span class="sd">        to provide the Modeldata with the data using the .set_model_from_csv()</span>
<span class="sd">        method.</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        Only 2mT extraction of ERA5 is implemented for all Modeldata instances.</span>
<span class="sd">        To extract other variables, one must create a Modeldata instance in</span>
<span class="sd">        advance, add or update a gee_dataset and give this Modeldata instance</span>
<span class="sd">        to this method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">modeldata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">Modl</span> <span class="o">=</span> <span class="n">Modeldata</span><span class="p">(</span><span class="n">modelname</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Modl</span> <span class="o">=</span> <span class="n">modeldata</span>
            <span class="n">modelname</span> <span class="o">=</span> <span class="n">Modl</span><span class="o">.</span><span class="n">modelname</span>

        <span class="c1"># Filters</span>

        <span class="k">if</span> <span class="n">startdt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">startdt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">startdt</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
                <span class="n">startdt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">enddt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">enddt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">enddt</span> <span class="o">=</span> <span class="n">fmt_datetime_argument</span><span class="p">(</span>
                <span class="n">enddt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># make shure bounds include required range</span>
        <span class="n">Model_time_res</span> <span class="o">=</span> <span class="n">Modl</span><span class="o">.</span><span class="n">mapinfo</span><span class="p">[</span><span class="n">Modl</span><span class="o">.</span><span class="n">modelname</span><span class="p">][</span><span class="s2">&quot;time_res&quot;</span><span class="p">]</span>
        <span class="n">startdt</span> <span class="o">=</span> <span class="n">startdt</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">Model_time_res</span><span class="p">)</span>
        <span class="n">enddt</span> <span class="o">=</span> <span class="n">enddt</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">Model_time_res</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">stations</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">loc</span><span class="p">[[</span><span class="n">stations</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stations</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">stations</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span>

        <span class="c1"># Convert to UTC</span>

        <span class="n">startdt_utc</span> <span class="o">=</span> <span class="n">startdt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>
        <span class="n">enddt_utc</span> <span class="o">=</span> <span class="n">enddt</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span><span class="n">pytz</span><span class="o">.</span><span class="n">utc</span><span class="p">)</span>

        <span class="c1"># fill modell with data</span>
        <span class="k">if</span> <span class="n">modelname</span> <span class="o">==</span> <span class="s2">&quot;ERA5_hourly&quot;</span><span class="p">:</span>
            <span class="n">Modl</span><span class="o">.</span><span class="n">get_ERA5_data</span><span class="p">(</span>
                <span class="n">metadf</span><span class="o">=</span><span class="n">metadf</span><span class="p">,</span>
                <span class="n">startdt_utc</span><span class="o">=</span><span class="n">startdt_utc</span><span class="p">,</span>
                <span class="n">enddt_utc</span><span class="o">=</span><span class="n">enddt_utc</span><span class="p">,</span>
                <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Modl</span><span class="o">.</span><span class="n">get_gee_dataset_data</span><span class="p">(</span>
                <span class="n">mapname</span><span class="o">=</span><span class="n">modelname</span><span class="p">,</span>
                <span class="n">metadf</span><span class="o">=</span><span class="n">metadf</span><span class="p">,</span>
                <span class="n">startdt_utc</span><span class="o">=</span><span class="n">startdt_utc</span><span class="p">,</span>
                <span class="n">enddt_utc</span><span class="o">=</span><span class="n">enddt_utc</span><span class="p">,</span>
                <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;(When using the .set_model_from_csv() method, make shure the modelname of your Modeldata is </span><span class="si">{</span><span class="n">modelname</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;(When using the .set_model_from_csv() method, make shure the modelname of your Modeldata is </span><span class="si">{</span><span class="n">modelname</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">Modl</span></div>


<div class="viewcode-block" id="Dataset.update_gaps_and_missing_from_outliers">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.update_gaps_and_missing_from_outliers.html#metobs_toolkit.Dataset.update_gaps_and_missing_from_outliers">[docs]</a>
    <span class="k">def</span> <span class="nf">update_gaps_and_missing_from_outliers</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">n_gapsize</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpret the outliers as missing observations.</span>

<span class="sd">        If there is a sequence</span>
<span class="sd">        of these outliers for a station, larger than n_gapsize than this will</span>
<span class="sd">        be interpreted as a gap.</span>

<span class="sd">        The outliers are not removed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : str, optional</span>
<span class="sd">            Use the outliers on this observation type to update the gaps and</span>
<span class="sd">            missing timestamps. The default is &#39;temp&#39;.</span>
<span class="sd">        n_gapsize : int, optional</span>
<span class="sd">            The minimum number of consecutive missing observations to define</span>
<span class="sd">            as a gap. If None, n_gapsize is taken from the settings defenition</span>
<span class="sd">            of gaps. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        Note</span>
<span class="sd">        -------</span>
<span class="sd">        Gaps and missing observations resulting from an outlier on a specific</span>
<span class="sd">        obstype, are assumed to be gaps/missing observation for all obstypes.</span>

<span class="sd">        Note</span>
<span class="sd">        ------</span>
<span class="sd">        Be aware that n_gapsize is used for the current resolution of the Dataset,</span>
<span class="sd">        this is different from the gap check applied on the inported data, if</span>
<span class="sd">        the dataset is coarsend.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">n_gapsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n_gapsize</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_settings&quot;</span><span class="p">][</span><span class="s2">&quot;gaps_finder&quot;</span><span class="p">][</span><span class="s2">&quot;gapsize_n&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;assumed_import_frequency&quot;</span><span class="p">]</span>
                <span class="o">.</span><span class="n">eq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">])</span>
                <span class="o">.</span><span class="n">all</span><span class="p">()</span>
            <span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The defenition of the gapsize (n_gapsize = </span><span class="si">{</span><span class="n">n_gapsize</span><span class="si">}</span><span class="s2">) </span><span class="se">\</span>
<span class="s2">                               will have another effect on the update of the gaps and missing </span><span class="se">\</span>
<span class="s2">                                   timestamps because coarsening is applied and the defenition </span><span class="se">\</span>
<span class="s2">                                   of the gapsize is not changed.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># combine to one dataframe</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_all_to_obsspace</span><span class="p">()</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="n">mergedf</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;obstype&quot;</span><span class="p">)</span>

        <span class="c1"># ignore labels</span>
        <span class="n">possible_outlier_labels</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">vals</span><span class="p">[</span><span class="s2">&quot;outlier_flag&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">vals</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="c1"># create groups when the final label changes</span>
        <span class="n">persistance_filter</span> <span class="o">=</span> <span class="p">((</span><span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">shift</span><span class="p">()</span> <span class="o">!=</span> <span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]))</span><span class="o">.</span><span class="n">cumsum</span><span class="p">()</span>
        <span class="n">grouped</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">groupby</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">persistance_filter</span><span class="p">])</span>

        <span class="c1"># locate new gaps by size of consecutive the same final label per station</span>
        <span class="n">group_sizes</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">size</span><span class="p">()</span>
        <span class="n">large_groups</span> <span class="o">=</span> <span class="n">group_sizes</span><span class="p">[</span><span class="n">group_sizes</span> <span class="o">&gt;</span> <span class="n">n_gapsize</span><span class="p">]</span>

        <span class="c1"># find only groups with final label as an outlier</span>
        <span class="n">gaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># new_gapsdf = pd.DataFrame()</span>
        <span class="n">new_gaps_idx</span> <span class="o">=</span> <span class="n">init_multiindex</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">group_idx</span> <span class="ow">in</span> <span class="n">large_groups</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">groupdf</span> <span class="o">=</span> <span class="n">grouped</span><span class="o">.</span><span class="n">get_group</span><span class="p">(</span><span class="n">group_idx</span><span class="p">)</span>
            <span class="n">group_final_label</span> <span class="o">=</span> <span class="n">groupdf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">group_final_label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">possible_outlier_labels</span><span class="p">:</span>
                <span class="c1"># no gap candidates</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">gap</span> <span class="o">=</span> <span class="n">Gap</span><span class="p">(</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">groupdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                    <span class="n">startdt</span><span class="o">=</span><span class="n">groupdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span>
                    <span class="n">enddt</span><span class="o">=</span><span class="n">groupdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span>
                <span class="p">)</span>

                <span class="n">gaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>
                <span class="n">new_gaps_idx</span> <span class="o">=</span> <span class="n">new_gaps_idx</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">groupdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># add all the outliers, that are not in the new gaps to the new missing obs</span>
        <span class="n">new_missing_obs</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">possible_outlier_labels</span><span class="p">)]</span><span class="o">.</span><span class="n">index</span>
        <span class="n">new_missing_obs</span> <span class="o">=</span> <span class="n">new_missing_obs</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">new_gaps_idx</span><span class="o">.</span><span class="n">to_numpy</span><span class="p">(),</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># to series</span>
        <span class="n">missing_obs_series</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">new_missing_obs</span><span class="o">.</span><span class="n">to_frame</span><span class="p">()</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="c1"># Create missing obs</span>
        <span class="n">new_missing_collection</span> <span class="o">=</span> <span class="n">Missingob_collection</span><span class="p">(</span><span class="n">missing_obs_series</span><span class="p">)</span>

        <span class="c1"># update self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">gaps</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span> <span class="o">+</span> <span class="n">new_missing_collection</span>

        <span class="c1"># remove outliers that are converted to gaps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">remove_gaps_from_outliers</span><span class="p">(</span>
            <span class="n">gaplist</span><span class="o">=</span><span class="n">gaps</span><span class="p">,</span> <span class="n">outldf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span>
        <span class="p">)</span>

        <span class="c1"># remove outliers that are converted to missing obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">remove_missing_from_outliers</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">)</span></div>


    <span class="c1"># =============================================================================</span>
    <span class="c1">#   Gap Filling</span>
    <span class="c1"># =============================================================================</span>

<div class="viewcode-block" id="Dataset.fill_gaps_automatic">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.fill_gaps_automatic.html#metobs_toolkit.Dataset.fill_gaps_automatic">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_gaps_automatic</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">modeldata</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">max_interpolate_duration_str</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">overwrite_fill</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill the gaps by using linear interpolation or debiased modeldata.</span>

<span class="sd">        The method that is applied to perform the gapfill will be determined by</span>
<span class="sd">        the duration of the gap.</span>

<span class="sd">        When the duration of a gap is smaller or equal than</span>
<span class="sd">        max_interpolation_duration, the linear interpolation method is applied</span>
<span class="sd">        else the debiased modeldata method.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modeldata : metobs_toolkit.Modeldata</span>
<span class="sd">            The modeldata to use for the gapfill. This model data should the required</span>
<span class="sd">            timeseries to fill all gaps present in the dataset.</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">            Name of the observationtype you want to apply gap filling on. The</span>
<span class="sd">            modeldata must contain this observation type as well. The</span>
<span class="sd">            default is &#39;temp&#39;.</span>
<span class="sd">        max_interpolate_duration_str : Timedelta or str, optional</span>
<span class="sd">            Maximum duration to apply interpolation for gapfill when using the</span>
<span class="sd">            automatic gapfill method. Gaps with longer durations will be filled</span>
<span class="sd">            using debiased modeldata. The default is None.</span>
<span class="sd">        overwrite_fill: bool, optional</span>
<span class="sd">            If a gap has already filled values, the interpolation of this gap</span>
<span class="sd">            is skipped if overwrite_fill is False. If set to True, the gapfill</span>
<span class="sd">            values and info will be overwitten. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        comb_df : TYPE</span>
<span class="sd">            gapfilldf : pandas.DataFrame</span>
<span class="sd">                A dataframe containing all the filled records.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#  ----------- Validate ----------------------------------------</span>

        <span class="c1"># check if modeldata is available</span>
        <span class="k">if</span> <span class="n">modeldata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The dataset has no modeldate. Use the set_modeldata() function to add modeldata.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># check if obstype is present in eramodel</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">obstype</span> <span class="ow">in</span> <span class="n">modeldata</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> is not present in the modeldate: </span><span class="si">{</span><span class="n">modeldata</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># check if all station are present in eramodeldata</span>
        <span class="c1"># stations = self.gaps.to_df().index.unique().to_list()</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">gap</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">]))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">sta</span> <span class="ow">in</span> <span class="n">modeldata</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;Not all stations with gaps are in the modeldata!&quot;</span>

        <span class="k">if</span> <span class="n">max_interpolate_duration_str</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">max_interpolate_duration_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_settings&quot;</span><span class="p">][</span>
                <span class="s2">&quot;automatic&quot;</span>
            <span class="p">][</span><span class="s2">&quot;max_interpolation_duration_str&quot;</span><span class="p">]</span>

        <span class="c1">#  ------------select the method to apply gapfill per gap ----------</span>
        <span class="n">interpolate_gaps</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">debias_gaps</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gap</span><span class="o">.</span><span class="n">duration</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">max_interpolate_duration_str</span><span class="p">):</span>
                <span class="n">interpolate_gaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">debias_gaps</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">gap</span><span class="p">)</span>

        <span class="c1"># 1   ---------------Fill by interpolation ---------------------</span>

        <span class="n">fill_settings_interp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_settings&quot;</span><span class="p">][</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span>

        <span class="n">apply_interpolate_gaps</span><span class="p">(</span>
            <span class="n">gapslist</span><span class="o">=</span><span class="n">interpolate_gaps</span><span class="p">,</span>
            <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">outliersdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span>
            <span class="n">dataset_res</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">],</span>
            <span class="n">gapfill_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_info&quot;</span><span class="p">],</span>
            <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">fill_settings_interp</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span>
            <span class="n">max_consec_fill</span><span class="o">=</span><span class="n">fill_settings_interp</span><span class="p">[</span><span class="s2">&quot;max_consec_fill&quot;</span><span class="p">],</span>
            <span class="n">overwrite_fill</span><span class="o">=</span><span class="n">overwrite_fill</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">filldf_interp</span> <span class="o">=</span> <span class="n">make_gapfill_df</span><span class="p">(</span><span class="n">interpolate_gaps</span><span class="p">)</span>

        <span class="c1"># 2  --------------  Fill by debias -----------------------------</span>

        <span class="n">fill_settings_debias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_settings&quot;</span><span class="p">][</span><span class="s2">&quot;model_debias&quot;</span><span class="p">]</span>

        <span class="n">apply_debias_era5_gapfill</span><span class="p">(</span>
            <span class="n">gapslist</span><span class="o">=</span><span class="n">debias_gaps</span><span class="p">,</span>
            <span class="n">dataset</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">eraModelData</span><span class="o">=</span><span class="n">modeldata</span><span class="p">,</span>
            <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="n">debias_settings</span><span class="o">=</span><span class="n">fill_settings_debias</span><span class="p">,</span>
            <span class="n">overwrite_fill</span><span class="o">=</span><span class="n">overwrite_fill</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># add label column</span>
        <span class="n">filldf_debias</span> <span class="o">=</span> <span class="n">make_gapfill_df</span><span class="p">(</span><span class="n">debias_gaps</span><span class="p">)</span>

        <span class="c1"># combine both fill df&#39;s</span>
        <span class="n">comb_df</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="n">filldf_interp</span><span class="p">,</span> <span class="n">filldf_debias</span><span class="p">])</span>

        <span class="c1"># update attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span> <span class="o">=</span> <span class="n">comb_df</span>

        <span class="k">return</span> <span class="n">comb_df</span></div>


<div class="viewcode-block" id="Dataset.fill_gaps_linear">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.fill_gaps_linear.html#metobs_toolkit.Dataset.fill_gaps_linear">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_gaps_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">overwrite_fill</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill the gaps using linear interpolation.</span>

<span class="sd">        The gapsfilldf attribute of the Datasetinstance will be updated if</span>
<span class="sd">        the gaps are not filled yet or if overwrite_fill is set to True.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : string, optional</span>
<span class="sd">            Fieldname to visualise. This can be an observation or station</span>
<span class="sd">            attribute. The default is &#39;temp&#39;.</span>
<span class="sd">        overwrite_fill: bool, optional</span>
<span class="sd">            If a gap has already filled values, the interpolation of this gap</span>
<span class="sd">            is skipped if overwrite_fill is False. If set to True, the gapfill</span>
<span class="sd">            values and info will be overwitten. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        gapfilldf : pandas.DataFrame</span>
<span class="sd">            A dataframe containing all the filled records.</span>


<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO logging</span>
        <span class="n">fill_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_settings&quot;</span><span class="p">][</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span>

        <span class="c1"># fill gaps</span>
        <span class="n">apply_interpolate_gaps</span><span class="p">(</span>
            <span class="n">gapslist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">,</span>
            <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">outliersdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span>
            <span class="n">dataset_res</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">],</span>
            <span class="n">gapfill_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_info&quot;</span><span class="p">],</span>
            <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">fill_settings</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span>
            <span class="n">max_consec_fill</span><span class="o">=</span><span class="n">fill_settings</span><span class="p">[</span><span class="s2">&quot;max_consec_fill&quot;</span><span class="p">],</span>
            <span class="n">overwrite_fill</span><span class="o">=</span><span class="n">overwrite_fill</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># get gapfilldf</span>
        <span class="n">gapfilldf</span> <span class="o">=</span> <span class="n">make_gapfill_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">)</span>

        <span class="c1"># update attr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span> <span class="o">=</span> <span class="n">gapfilldf</span>

        <span class="k">return</span> <span class="n">gapfilldf</span></div>


<div class="viewcode-block" id="Dataset.fill_missing_obs_linear">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.fill_missing_obs_linear.html#metobs_toolkit.Dataset.fill_missing_obs_linear">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_missing_obs_linear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate missing observations.</span>

<span class="sd">        Fill in the missing observation rectords using interpolation. The</span>
<span class="sd">        missing_fill_df attribute of the Dataset will be updated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : string, optional</span>
<span class="sd">            Fieldname to visualise. This can be an observation or station</span>
<span class="sd">            attribute. The default is &#39;temp&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO logging</span>
        <span class="n">fill_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">missing_obs</span><span class="p">[</span><span class="s2">&quot;missing_obs_fill_settings&quot;</span><span class="p">][</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span>
        <span class="n">fill_info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">missing_obs</span><span class="p">[</span><span class="s2">&quot;missing_obs_fill_info&quot;</span><span class="p">]</span>

        <span class="c1"># fill missing obs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">interpolate_missing</span><span class="p">(</span>
            <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">resolutionseries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">],</span>
            <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="n">fill_settings</span><span class="p">[</span><span class="s2">&quot;method&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">missing_fill_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">fill_df</span>

        <span class="n">missing_fill_df</span><span class="p">[</span><span class="n">obstype</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">fill_info</span><span class="p">[</span><span class="s2">&quot;label_columnname&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">fill_info</span><span class="p">[</span>
            <span class="s2">&quot;label&quot;</span>
        <span class="p">][</span><span class="s2">&quot;linear&quot;</span><span class="p">]</span>

        <span class="c1"># Update attribute</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">missing_fill_df</span> <span class="o">=</span> <span class="n">missing_fill_df</span></div>


<div class="viewcode-block" id="Dataset.get_gaps_df">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_gaps_df.html#metobs_toolkit.Dataset.get_gaps_df">[docs]</a>
    <span class="k">def</span> <span class="nf">get_gaps_df</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        List all gaps into an overview dataframe.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame</span>
<span class="sd">            A DataFrame with stationnames as index, and the start, end and duretion</span>
<span class="sd">            of the gaps as columns.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">gaps_to_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.get_gaps_info">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_gaps_info.html#metobs_toolkit.Dataset.get_gaps_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_gaps_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print out detailed information of the gaps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">):</span>
            <span class="c1"># there are gaps</span>
            <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">:</span>
                <span class="n">gap</span><span class="o">.</span><span class="n">get_info</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># no gaps</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;There are no gaps.&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.get_missing_obs_info">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_missing_obs_info.html#metobs_toolkit.Dataset.get_missing_obs_info">[docs]</a>
    <span class="k">def</span> <span class="nf">get_missing_obs_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Print out detailed information of the missing observations.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># empty obs protector in the .get_info method.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">get_info</span><span class="p">()</span></div>


<div class="viewcode-block" id="Dataset.get_analysis">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_analysis.html#metobs_toolkit.Dataset.get_analysis">[docs]</a>
    <span class="k">def</span> <span class="nf">get_analysis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_gapfilled_values</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create an Analysis instance from the Dataframe.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        add_gapfilled_values : bool, optional</span>
<span class="sd">            If True, all filled values (from gapfill and missing observation fill),</span>
<span class="sd">            are added to the analysis records aswell. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        metobs_toolkit.Analysis</span>
<span class="sd">            The Analysis instance of the Dataset.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># combine all to obsspace and include gapfill</span>
        <span class="k">if</span> <span class="n">add_gapfilled_values</span><span class="p">:</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_all_to_obsspace</span><span class="p">()</span>

            <span class="c1"># gapsfilled labels</span>
            <span class="n">gapfill_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_info&quot;</span><span class="p">]</span>
            <span class="n">gapfilllabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">gapfill_settings</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

            <span class="c1"># missingfilled labels</span>
            <span class="n">missingfill_settings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">missing_obs</span><span class="p">[</span><span class="s2">&quot;missing_obs_fill_info&quot;</span><span class="p">]</span>
            <span class="n">missingfilllabels</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">missingfill_settings</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">()]</span>

            <span class="c1"># get all labels</span>
            <span class="n">fill_labels</span> <span class="o">=</span> <span class="n">gapfilllabels</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">fill_labels</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">missingfilllabels</span><span class="p">)</span>
            <span class="n">fill_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;ok&quot;</span><span class="p">)</span>

            <span class="n">df</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">fill_labels</span><span class="p">)]</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[[</span><span class="s2">&quot;value&quot;</span><span class="p">]]</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s2">&quot;obstype&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>

        <span class="k">return</span> <span class="n">Analysis</span><span class="p">(</span>
            <span class="n">obsdf</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
            <span class="n">settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="p">,</span>
            <span class="n">data_template</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.fill_gaps_era5">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.fill_gaps_era5.html#metobs_toolkit.Dataset.fill_gaps_era5">[docs]</a>
    <span class="k">def</span> <span class="nf">fill_gaps_era5</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">modeldata</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;debias&quot;</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">overwrite_fill</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill the gaps using a Modeldata object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        modeldata : metobs_toolkit.Modeldata</span>
<span class="sd">            The modeldata to use for the gapfill. This model data should the required</span>
<span class="sd">            timeseries to fill all gaps present in the dataset.</span>
<span class="sd">        method : &#39;debias&#39;, optional</span>
<span class="sd">            Specify which method to use. The default is &#39;debias&#39;.</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">           Name of the observationtype you want to apply gap filling on. The</span>
<span class="sd">           modeldata must contain this observation type as well. The</span>
<span class="sd">           default is &#39;temp&#39;.</span>
<span class="sd">        overwrite_fill: bool, optional</span>
<span class="sd">            If a gap has already filled values, the interpolation of this gap</span>
<span class="sd">            is skipped if overwrite_fill is False. If set to True, the gapfill</span>
<span class="sd">            values and info will be overwitten. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Gapfilldf : pandas.DataFrame</span>
<span class="sd">            A dataframe containing all gap filled values and the use method.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># check if modeldata is available</span>
        <span class="k">if</span> <span class="n">modeldata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;The dataset has no modeldate. Use the set_modeldata() function to add modeldata.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># check if obstype is present in eramodel</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="n">obstype</span> <span class="ow">in</span> <span class="n">modeldata</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> is not present in the modeldate: </span><span class="si">{</span><span class="n">modeldata</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="c1"># check if all station are present in eramodeldata</span>
        <span class="c1"># stations = self.gaps.to_df().index.unique().to_list()</span>
        <span class="n">stations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">gap</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">gap</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">]))</span>
        <span class="k">assert</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span><span class="n">sta</span> <span class="ow">in</span> <span class="n">modeldata</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">stations</span><span class="p">]</span>
        <span class="p">),</span> <span class="s2">&quot;Not all stations with gaps are in the modeldata!&quot;</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;debias&quot;</span><span class="p">:</span>

            <span class="n">fill_settings_debias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_fill_settings&quot;</span><span class="p">][</span>
                <span class="s2">&quot;model_debias&quot;</span>
            <span class="p">]</span>

            <span class="n">apply_debias_era5_gapfill</span><span class="p">(</span>
                <span class="n">gapslist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">,</span>
                <span class="n">dataset</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">eraModelData</span><span class="o">=</span><span class="n">modeldata</span><span class="p">,</span>
                <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                <span class="n">debias_settings</span><span class="o">=</span><span class="n">fill_settings_debias</span><span class="p">,</span>
                <span class="n">overwrite_fill</span><span class="o">=</span><span class="n">overwrite_fill</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># get fill df</span>
            <span class="n">filldf</span> <span class="o">=</span> <span class="n">make_gapfill_df</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> not implemented yet&quot;</span><span class="p">)</span>

        <span class="c1"># update attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span> <span class="o">=</span> <span class="n">filldf</span>

        <span class="k">return</span> <span class="n">filldf</span></div>


<div class="viewcode-block" id="Dataset.write_to_csv">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.write_to_csv.html#metobs_toolkit.Dataset.write_to_csv">[docs]</a>
    <span class="k">def</span> <span class="nf">write_to_csv</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">include_outliers</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">include_fill_values</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">add_final_labels</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">use_tlk_obsnames</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">overwrite_outliers_by_gaps_and_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">seperate_metadata_file</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write Dataset to a csv file.</span>

<span class="sd">        Write the dataset to a file where the observations, metadata and</span>
<span class="sd">        (if available) the quality labels per observation type are merged</span>
<span class="sd">        together.</span>

<span class="sd">        A final qualty control label for each</span>
<span class="sd">        quality-controlled-observation type can be added in the outputfile.</span>

<span class="sd">        The file will be writen to the outputfolder specified in the settings.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : string, optional</span>
<span class="sd">            Specify an observation type to subset all observations to. If None,</span>
<span class="sd">            all available observation types are writen to file. The default is</span>
<span class="sd">            None.</span>
<span class="sd">        filename : string, optional</span>
<span class="sd">            The name of the output csv file. If none, a standard-filename</span>
<span class="sd">            is generated based on the period of data. The default is None.</span>
<span class="sd">        include_outliers : bool, optional</span>
<span class="sd">            If True, the outliers will be present in the csv file. The default is True.</span>
<span class="sd">        include_fill_values : bool, optional</span>
<span class="sd">            If True, the filled gap and missing observation values will be</span>
<span class="sd">            present in the csv file. The default is True.</span>
<span class="sd">        add_final_labels : bool, optional</span>
<span class="sd">            If True, a column is added containing the final label of an observation. The default is True.</span>
<span class="sd">        use_tlk_obsnames : bool, optional</span>
<span class="sd">            If True, the standard naming of the metobs_toolkit is used, else</span>
<span class="sd">            the original names for obstypes is used. The default is True.</span>
<span class="sd">        overwrite_outliers_by_gaps_and_missing : bool, optional</span>
<span class="sd">            If the gaps and missing observations are updated using outliers,</span>
<span class="sd">            interpret these records as gaps/missing outliers if True. Else these</span>
<span class="sd">            will be interpreted as outliers. The default is True.</span>
<span class="sd">        seperate_metadata_file : bool, optional</span>
<span class="sd">            If true, the metadat is writen to a seperate file, else the metadata</span>
<span class="sd">            is merged to the observation in one file. The default is True.</span>
<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Writing the dataset to a csv file&quot;</span><span class="p">)</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="p">),</span> <span class="s2">&quot;Specify Settings.output_folder in order to export a csv.&quot;</span>

        <span class="k">assert</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s1">&#39;The outputfolder: </span><span class="se">\</span>
<span class="s1">            </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> is not found. &#39;</span>

        <span class="c1"># combine all dataframes</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_all_to_obsspace</span><span class="p">(</span>
            <span class="n">overwrite_outliers_by_gaps_and_missing</span><span class="o">=</span><span class="n">overwrite_outliers_by_gaps_and_missing</span>
        <span class="p">)</span>  <span class="c1"># with outliers</span>
        <span class="c1"># Unstack mergedf</span>
        <span class="c1"># remove duplicates</span>
        <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="o">~</span><span class="n">mergedf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)]</span>

        <span class="c1"># drop outliers if required</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_outliers</span><span class="p">:</span>
            <span class="n">outlier_labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">var</span><span class="p">[</span><span class="s2">&quot;outlier_flag&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">]</span>
            <span class="p">]</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="o">~</span><span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">outlier_labels</span><span class="p">)]</span>

        <span class="c1"># drop fill values if required</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_fill_values</span><span class="p">:</span>
            <span class="n">fill_labels</span> <span class="o">=</span> <span class="p">[</span>
                <span class="s2">&quot;gap fill&quot;</span><span class="p">,</span>
                <span class="s2">&quot;missing observation fill&quot;</span><span class="p">,</span>
            <span class="p">]</span>  <span class="c1"># toolkit representation labels</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="o">~</span><span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">fill_labels</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">obstype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="n">mergedf</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;obstype&quot;</span><span class="p">,</span> <span class="n">drop_level</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Map obstypes columns</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">use_tlk_obsnames</span><span class="p">:</span>
            <span class="n">mapper</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">col</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">get_orig_name</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;new_names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mergedf</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">mapper</span><span class="p">)</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">])</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;new_names&quot;</span><span class="p">:</span> <span class="s2">&quot;obstype&quot;</span><span class="p">})</span>
            <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;obstype&quot;</span><span class="p">])</span>

        <span class="n">mergedf</span> <span class="o">=</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">unstack</span><span class="p">(</span><span class="s2">&quot;obstype&quot;</span><span class="p">)</span>

        <span class="c1"># to one level for the columns</span>
        <span class="n">mergedf</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; : &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">col</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">mergedf</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">values</span><span class="p">]</span>

        <span class="c1"># columns to write</span>
        <span class="n">write_dataset_to_csv</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">mergedf</span><span class="p">,</span>
            <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
            <span class="n">filename</span><span class="o">=</span><span class="n">filename</span><span class="p">,</span>
            <span class="n">outputfolder</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">],</span>
            <span class="n">location_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;location_info&quot;</span><span class="p">],</span>
            <span class="n">seperate_metadata_file</span><span class="o">=</span><span class="n">seperate_metadata_file</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="c1"># =============================================================================</span>
    <span class="c1">#     Quality control</span>
    <span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="Dataset.apply_quality_control">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.apply_quality_control.html#metobs_toolkit.Dataset.apply_quality_control">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_quality_control</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">gross_value</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">persistance</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">repetitions</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">step</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">window_variation</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply quality control methods to the dataset.</span>

<span class="sd">        The default settings are used, and can be changed in the</span>
<span class="sd">        settings_files/qc_settings.py</span>

<span class="sd">        The checks are performed in a sequence: gross_vallue --&gt;</span>
<span class="sd">        persistance --&gt; ..., Outliers by a previous check are ignored in the</span>
<span class="sd">        following checks!</span>

<span class="sd">        The dataset is updated inline.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">            Name of the observationtype you want to apply the checks on. The</span>
<span class="sd">            default is &#39;temp&#39;.</span>
<span class="sd">        gross_value : Bool, optional</span>
<span class="sd">            If True the gross_value check is applied if False not. The default</span>
<span class="sd">            is True.</span>
<span class="sd">        persistance : Bool, optional</span>
<span class="sd">            If True the persistance check is applied if False not. The default</span>
<span class="sd">            is True.. The default is True.</span>
<span class="sd">        repetition : Bool, optional</span>
<span class="sd">            If True the repetations check is applied if False not. The default</span>
<span class="sd">            is True.</span>
<span class="sd">        step : Bool, optional</span>
<span class="sd">            If True the step check is applied if False not. The default is True.</span>
<span class="sd">        window_variation : Bool, optional</span>
<span class="sd">            If True the window_variation check is applied if False not. The</span>
<span class="sd">            default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">repetitions</span><span class="p">:</span>
            <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="s2">&quot;repetitions&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying repetitions check.&quot;</span><span class="p">)</span>

                <span class="n">obsdf</span><span class="p">,</span> <span class="n">outl_df</span> <span class="o">=</span> <span class="n">repetitions_check</span><span class="p">(</span>
                    <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                    <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                    <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># update the dataset and outliers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outl_df</span><span class="p">])</span>

                <span class="c1"># add this check to the applied checks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                        <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                            <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="s2">&quot;repetitions&quot;</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">gross_value</span><span class="p">:</span>
            <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="s2">&quot;gross_value&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying gross value check.&quot;</span><span class="p">)</span>

                <span class="n">obsdf</span><span class="p">,</span> <span class="n">outl_df</span> <span class="o">=</span> <span class="n">gross_value_check</span><span class="p">(</span>
                    <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                    <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                    <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># update the dataset and outliers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outl_df</span><span class="p">])</span>

                <span class="c1"># add this check to the applied checks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                        <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                            <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="s2">&quot;gross_value&quot;</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">persistance</span><span class="p">:</span>
            <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="s2">&quot;persistance&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying persistance check.&quot;</span><span class="p">)</span>
                <span class="n">obsdf</span><span class="p">,</span> <span class="n">outl_df</span> <span class="o">=</span> <span class="n">persistance_check</span><span class="p">(</span>
                    <span class="n">station_frequencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">],</span>
                    <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                    <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                    <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># update the dataset and outliers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outl_df</span><span class="p">])</span>

                <span class="c1"># add this check to the applied checks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                        <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                            <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="s2">&quot;persistance&quot;</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">step</span><span class="p">:</span>
            <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="s2">&quot;step&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying step-check.&quot;</span><span class="p">)</span>
                <span class="n">obsdf</span><span class="p">,</span> <span class="n">outl_df</span> <span class="o">=</span> <span class="n">step_check</span><span class="p">(</span>
                    <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                    <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                    <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># update the dataset and outliers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outl_df</span><span class="p">])</span>

                <span class="c1"># add this check to the applied checks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                        <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                            <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="s2">&quot;step&quot;</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">window_variation</span><span class="p">:</span>
            <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="s2">&quot;window_variation&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying window variation-check.&quot;</span><span class="p">)</span>
                <span class="n">obsdf</span><span class="p">,</span> <span class="n">outl_df</span> <span class="o">=</span> <span class="n">window_variation_check</span><span class="p">(</span>
                    <span class="n">station_frequencies</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">],</span>
                    <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                    <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                    <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                    <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
                <span class="p">)</span>

                <span class="c1"># update the dataset and outliers</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outl_df</span><span class="p">])</span>

                <span class="c1"># add this check to the applied checks</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                        <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                            <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="s2">&quot;window_variation&quot;</span>
                        <span class="p">),</span>
                    <span class="p">],</span>
                    <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_qc_checked_obstypes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obstype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_qc_checked_obstypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_qc_checked_obstypes</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span></div>


<div class="viewcode-block" id="Dataset.apply_buddy_check">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.apply_buddy_check.html#metobs_toolkit.Dataset.apply_buddy_check">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_buddy_check</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span>
        <span class="n">use_constant_altitude</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">haversine_approx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">metric_epsg</span><span class="o">=</span><span class="s2">&quot;31370&quot;</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the buddy check on the observations.</span>

<span class="sd">        The buddy check compares an observation against its neighbours (i.e.</span>
<span class="sd">        buddies). The check looks for buddies in a neighbourhood specified by</span>
<span class="sd">        a certain radius. The buddy check flags observations if the</span>
<span class="sd">        (absolute value of the) difference between the observations and the</span>
<span class="sd">        average of the neighbours normalized by the standard deviation in the</span>
<span class="sd">        circle is greater than a predefined threshold.</span>

<span class="sd">        This check is based on the buddy check from titanlib. Documentation on</span>
<span class="sd">        the titanlib buddy check can be found</span>
<span class="sd">        `here &lt;https://github.com/metno/titanlib/wiki/Buddy-check&gt;`_.</span>


<span class="sd">        The observation and outliers attributes will be updated accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">            Name of the observationtype you want to apply the checks on. The</span>
<span class="sd">            default is &#39;temp&#39;.</span>
<span class="sd">        use_constant_altitude : bool, optional</span>
<span class="sd">            Use a constant altitude for all stations. The default is False.</span>
<span class="sd">        haversine_approx : bool, optional</span>
<span class="sd">            Use the haversine approximation (earth is a sphere) to calculate</span>
<span class="sd">            distances between stations. The default is True.</span>
<span class="sd">        metric_epsg : str, optional</span>
<span class="sd">            EPSG code for the metric CRS to calculate distances in. Only used when</span>
<span class="sd">            haversine approximation is set to False. Thus becoming a better</span>
<span class="sd">            distance approximation but not global applicable The default is &#39;31370&#39;</span>
<span class="sd">            (which is suitable for Belgium).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying the toolkit buddy check&quot;</span><span class="p">)</span>

        <span class="n">checkname</span> <span class="o">=</span> <span class="s2">&quot;buddy_check&quot;</span>

        <span class="c1"># 1. coordinates are available?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not all coordinates are available, the </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not all coordinates are available, the </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># set constant altitude if needed:</span>

        <span class="c1"># if altitude is already available, save it to restore it after this check</span>
        <span class="n">restore_altitude</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">use_constant_altitude</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;altitulde&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude_backup&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span>
                <span class="n">restore_altitude</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># absolut value does not matter</span>

        <span class="c1"># 2. altitude available?</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_constant_altitude</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s2">&quot;altitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The altitude is not known for all stations. The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;(To resolve this error you can: </span><span class="se">\n</span><span class="s1"> *Use the Dataset.get_altitude() method </span><span class="se">\n</span><span class="s1"> *Set use_constant_altitude to True </span><span class="se">\n</span><span class="s1"> update the &quot;altitude&quot; column in the metadf attribute of your Dataset.&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_constant_altitude</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The altitude is not known for all stations. The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;(To resolve this error you can: </span><span class="se">\n</span><span class="s1"> *Use the Dataset.get_altitude() method </span><span class="se">\n</span><span class="s1"> *Set use_constant_altitude to True </span><span class="se">\n</span><span class="s1"> *Update the &quot;altitude&quot; column in the metadf attribute of your Dataset.)&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">checkname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
            <span class="n">buddy_set</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span><span class="n">obstype</span><span class="p">]</span>
            <span class="n">outl_flag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span><span class="s2">&quot;outlier_flag&quot;</span><span class="p">]</span>
            <span class="n">obsdf</span><span class="p">,</span> <span class="n">outliersdf</span> <span class="o">=</span> <span class="n">toolkit_buddy_check</span><span class="p">(</span>
                <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
                <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                <span class="n">buddy_radius</span><span class="o">=</span><span class="n">buddy_set</span><span class="p">[</span><span class="s2">&quot;radius&quot;</span><span class="p">],</span>
                <span class="n">min_sample_size</span><span class="o">=</span><span class="n">buddy_set</span><span class="p">[</span><span class="s2">&quot;num_min&quot;</span><span class="p">],</span>
                <span class="n">max_alt_diff</span><span class="o">=</span><span class="n">buddy_set</span><span class="p">[</span><span class="s2">&quot;max_elev_diff&quot;</span><span class="p">],</span>
                <span class="n">min_std</span><span class="o">=</span><span class="n">buddy_set</span><span class="p">[</span><span class="s2">&quot;min_std&quot;</span><span class="p">],</span>
                <span class="n">std_threshold</span><span class="o">=</span><span class="n">buddy_set</span><span class="p">[</span><span class="s2">&quot;threshold&quot;</span><span class="p">],</span>
                <span class="n">metric_epsg</span><span class="o">=</span><span class="n">metric_epsg</span><span class="p">,</span>
                <span class="n">lapserate</span><span class="o">=</span><span class="n">buddy_set</span><span class="p">[</span><span class="s2">&quot;elev_gradient&quot;</span><span class="p">],</span>
                <span class="n">outl_flag</span><span class="o">=</span><span class="n">outl_flag</span><span class="p">,</span>
                <span class="n">haversine_approx</span><span class="o">=</span><span class="n">haversine_approx</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># update the dataset and outliers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">outliersdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outliersdf</span><span class="p">])</span>

            <span class="c1"># add this check to the applied checks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                    <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                        <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="n">checkname</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> can NOT be applied on </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> because it was already applied on this observation type!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Revert artificial data that has been added if needed</span>
        <span class="k">if</span> <span class="n">restore_altitude</span><span class="p">:</span>  <span class="c1"># altitude was overwritten, thus revert it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude_backup&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;altitude_backup&quot;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">use_constant_altitude</span><span class="p">:</span>
            <span class="c1"># when no alitude was available apriori, remove the fake constant altitude column</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Dataset.apply_titan_buddy_check">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.apply_titan_buddy_check.html#metobs_toolkit.Dataset.apply_titan_buddy_check">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_titan_buddy_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">use_constant_altitude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the TITAN buddy check on the observations.</span>

<span class="sd">        The buddy check compares an observation against its neighbours (i.e. buddies). The check looks for</span>
<span class="sd">        buddies in a neighbourhood specified by a certain radius. The buddy check flags observations if the</span>
<span class="sd">        (absolute value of the) difference between the observations and the average of the neighbours</span>
<span class="sd">        normalized by the standard deviation in the circle is greater than a predefined threshold.</span>

<span class="sd">        See the `titanlib documentation on the buddy check &lt;https://github.com/metno/titanlib/wiki/Buddy-check&gt;`_</span>
<span class="sd">        for futher details.</span>

<span class="sd">        The observation and outliers attributes will be updated accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">            Name of the observationtype you want to apply the checks on. The</span>
<span class="sd">            default is &#39;temp&#39;.</span>
<span class="sd">        use_constant_altitude : bool, optional</span>
<span class="sd">            Use a constant altitude for all stations. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        Note</span>
<span class="sd">        -------</span>
<span class="sd">        To update the check settings, use the update_titan_qc_settings method</span>
<span class="sd">        of the Dataset class.</span>

<span class="sd">        Warning</span>
<span class="sd">        --------</span>
<span class="sd">        To use this method, you must install titanlib. Windows users must have</span>
<span class="sd">        a c++ compiler installed. See the titanlib documentation: https://github.com/metno/titanlib/wiki/Installation.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying the titan buddy check&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">titanlib</span>

            <span class="c1"># Add version restrictions??</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Titanlib is not installed, install it manually if you want to use this functionallity.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">checkname</span> <span class="o">=</span> <span class="s2">&quot;titan_buddy_check&quot;</span>

        <span class="c1"># 1. coordinates are available?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not all coordinates are available, the </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not all coordinates are available, the </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># set constant altitude if needed:</span>

        <span class="c1"># if altitude is already available, save it to restore it after this check</span>
        <span class="n">restore_altitude</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">use_constant_altitude</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;altitulde&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude_backup&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span>
                <span class="n">restore_altitude</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span>  <span class="c1"># absolut value does not matter</span>

        <span class="c1"># 2. altitude available?</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_constant_altitude</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="s2">&quot;altitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The altitude is not known for all stations. The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;(To resolve this error you can: </span><span class="se">\n</span><span class="s1"> *Use the Dataset.get_altitude() method </span><span class="se">\n</span><span class="s1"> *Set use_constant_altitude to True </span><span class="se">\n</span><span class="s1"> update the &quot;altitude&quot; column in the metadf attribute of your Dataset.&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">use_constant_altitude</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The altitude is not known for all stations. The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;(To resolve this error you can: </span><span class="se">\n</span><span class="s1"> *Use the Dataset.get_altitude() method </span><span class="se">\n</span><span class="s1"> *Set use_constant_altitude to True </span><span class="se">\n</span><span class="s1"> *Update the &quot;altitude&quot; column in the metadf attribute of your Dataset.)&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">checkname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
            <span class="n">obsdf</span><span class="p">,</span> <span class="n">outliersdf</span> <span class="o">=</span> <span class="n">titan_buddy_check</span><span class="p">(</span>
                <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
                <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;titan_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span>
                    <span class="n">obstype</span>
                <span class="p">],</span>
                <span class="n">titan_specific_labeler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;titan_specific_labeler&quot;</span><span class="p">][</span>
                    <span class="n">checkname</span>
                <span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># update the dataset and outliers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">outliersdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outliersdf</span><span class="p">])</span>

            <span class="c1"># add this check to the applied checks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                    <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                        <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="n">checkname</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> can NOT be applied on </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> because it was already applied on this observation type!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Revert artificial data that has been added if needed</span>
        <span class="k">if</span> <span class="n">restore_altitude</span><span class="p">:</span>  <span class="c1"># altitude was overwritten, thus revert it</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude_backup&quot;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;altitude_backup&quot;</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">use_constant_altitude</span><span class="p">:</span>
            <span class="c1"># when no alitude was available apriori, remove the fake constant altitude column</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Dataset.apply_titan_sct_resistant_check">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.apply_titan_sct_resistant_check.html#metobs_toolkit.Dataset.apply_titan_sct_resistant_check">[docs]</a>
    <span class="k">def</span> <span class="nf">apply_titan_sct_resistant_check</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Apply the TITAN spatial consistency test (resistant).</span>

<span class="sd">        The SCT resistant check is a spatial consistency check which compares each observations to what is expected given the other observations in the</span>
<span class="sd">        nearby area. If the deviation is large, the observation is removed. The SCT uses optimal interpolation</span>
<span class="sd">        (OI) to compute an expected value for each observation. The background for the OI is computed from</span>
<span class="sd">        a general vertical profile of observations in the area.</span>

<span class="sd">        See the `titanlib documentation on the sct check &lt;https://github.com/metno/titanlib/wiki/Spatial-consistency-test-resistant&gt;`_</span>
<span class="sd">        for futher details.</span>

<span class="sd">        The observation and outliers attributes will be updated accordingly.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obstype : String, optional</span>
<span class="sd">            Name of the observationtype you want to apply the checks on. The</span>
<span class="sd">            default is &#39;temp&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        Note</span>
<span class="sd">        -------</span>
<span class="sd">        To update the check settings, use the update_titan_qc_settings method</span>
<span class="sd">        of the Dataset class.</span>

<span class="sd">        Warning</span>
<span class="sd">        --------</span>
<span class="sd">        To use this method, you must install titanlib. Windows users must have</span>
<span class="sd">        a c++ compiler installed. See the titanlib documentation: https://github.com/metno/titanlib/wiki/Installation.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        This method is a python wrapper on titanlib c++ scripts, and it is prone</span>
<span class="sd">        to segmentation faults. The perfomance of this check is thus not</span>
<span class="sd">        guaranteed!</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Applying the titan SCT check&quot;</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">titanlib</span>

            <span class="c1"># Add version restrictions??</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Titanlib is not installed, install it manually if you want to use this functionallity.&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">checkname</span> <span class="o">=</span> <span class="s2">&quot;titan_sct_resistant_check&quot;</span>
        <span class="c1"># check if required metadata is available:</span>

        <span class="c1"># 1. coordinates are available?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lat&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not all coordinates are available, the </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;lon&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Not all coordinates are available, the </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># 2. altitude available?</span>
        <span class="k">if</span> <span class="s2">&quot;altitude&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The altitude is not known for all stations. The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;(To resolve this error you can: </span><span class="se">\n</span><span class="s1"> *Use the Dataset.get_altitude() method </span><span class="se">\n</span><span class="s1"> *Set use_constant_altitude to True </span><span class="se">\n</span><span class="s1"> update the &quot;altitude&quot; column in the metadf attribute of your Dataset.&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The altitude is not known for all stations. The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> cannot be executed!&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;(To resolve this error you can: </span><span class="se">\n</span><span class="s1"> *Use the Dataset.get_altitude() method </span><span class="se">\n</span><span class="s1"> *Set use_constant_altitude to True </span><span class="se">\n</span><span class="s1"> *Update the &quot;altitude&quot; column in the metadf attribute of your Dataset.)&#39;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="n">apliable</span> <span class="o">=</span> <span class="n">_can_qc_be_applied</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">checkname</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">apliable</span><span class="p">:</span>
            <span class="n">obsdf</span><span class="p">,</span> <span class="n">outliersdf</span> <span class="o">=</span> <span class="n">titan_sct_resistant_check</span><span class="p">(</span>
                <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
                <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
                <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;titan_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span>
                    <span class="n">obstype</span>
                <span class="p">],</span>
                <span class="n">titan_specific_labeler</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;titan_specific_labeler&quot;</span><span class="p">][</span>
                    <span class="n">checkname</span>
                <span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># update the dataset and outliers</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">obsdf</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">outliersdf</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">outliersdf</span><span class="p">])</span>

            <span class="c1"># add this check to the applied checks</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                    <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                        <span class="n">obstypes</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="n">checkname</span>
                    <span class="p">),</span>
                <span class="p">],</span>
                <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> can NOT be applied on </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> because it was already applied on this observation type!&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.combine_all_to_obsspace">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.combine_all_to_obsspace.html#metobs_toolkit.Dataset.combine_all_to_obsspace">[docs]</a>
    <span class="k">def</span> <span class="nf">combine_all_to_obsspace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">repr_outl_as_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">overwrite_outliers_by_gaps_and_missing</span><span class="o">=</span><span class="kc">True</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make one dataframe with all observations and their labels.</span>

<span class="sd">        Combine all observations, outliers, missing observations and gaps into</span>
<span class="sd">        one Dataframe. All observation types are combined an a label is added</span>
<span class="sd">        in a serperate column.</span>

<span class="sd">        When gaps and missing records are updated from outliers one has to choice</span>
<span class="sd">        to represent these records as outliers or gaps. There can not be duplicates</span>
<span class="sd">        in the return dataframe.</span>

<span class="sd">        By default the observation values of the outliers are saved, one can</span>
<span class="sd">        choice to use these values or NaN&#39;s.</span>
<span class="sd">        following checks!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        repr_outl_as_nan : bool, optional</span>
<span class="sd">            If True, Nan&#39;s are use for the values of the outliers. The</span>
<span class="sd">            default is False.</span>
<span class="sd">        overwrite_outliers_by_gaps_and_missing : Bool, optional</span>
<span class="sd">            If True, records that are labeld as gap/missing and outlier are</span>
<span class="sd">            labeled as gaps/missing. This has only effect when the gaps/missing</span>
<span class="sd">            observations are updated from the outliers. The default is True.</span>

<span class="sd">         Returns</span>
<span class="sd">         ---------</span>
<span class="sd">         combdf : pandas.DataFrame()</span>
<span class="sd">            A dataframe containing a continious time resolution of records, where each</span>
<span class="sd">            record is labeld.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: label values from settings not hardcoding</span>

        <span class="c1"># TODO: use the repr_outl_as_nan argumenten here</span>
        <span class="c1"># =============================================================================</span>
        <span class="c1"># Stack observations and outliers</span>
        <span class="c1"># =============================================================================</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="c1"># better save than sorry</span>
        <span class="n">present_obstypes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">present_obstypes</span><span class="p">]</span>

        <span class="c1"># to tripple index</span>
        <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">df</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;level_2&quot;</span><span class="p">:</span> <span class="s2">&quot;obstype&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;obstype&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;ok&quot;</span>
        <span class="n">df</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;observation&quot;</span>

        <span class="c1"># outliers</span>
        <span class="n">outliersdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">outliersdf</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;outlier&quot;</span>

        <span class="c1"># Careful! Some outliers exist on inport frequency (duplicated, invalid)</span>
        <span class="c1"># So only use the outliers for which station-datetime-obstype are present in the</span>
        <span class="c1"># dataset.df</span>
        <span class="n">outliersdf</span> <span class="o">=</span> <span class="n">outliersdf</span><span class="p">[</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

        <span class="c1"># remove outliers from the observations</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

        <span class="c1"># =============================================================================</span>
        <span class="c1"># Stack gaps</span>
        <span class="c1"># =============================================================================</span>
        <span class="c1"># add gapfill and remove the filled records from gaps</span>
        <span class="n">gapsfilldf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># to triple index</span>
        <span class="n">gapsfilldf</span> <span class="o">=</span> <span class="n">value_labeled_doubleidxdf_to_triple_idxdf</span><span class="p">(</span>
            <span class="n">gapsfilldf</span><span class="p">,</span> <span class="n">known_obstypes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">gapsfilldf</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gap fill&quot;</span>

        <span class="n">gapsidx</span> <span class="o">=</span> <span class="n">get_gaps_indx_in_obs_space</span><span class="p">(</span>
            <span class="n">gapslist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">,</span>
            <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">outliersdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span>
            <span class="n">resolutionseries</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="n">gapsdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">gapsidx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">present_obstypes</span><span class="p">)</span>
        <span class="n">gapsdf</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">gapsdf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;level_2&quot;</span><span class="p">:</span> <span class="s2">&quot;obstype&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;obstype&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">gapsdf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_info&quot;</span><span class="p">][</span><span class="s2">&quot;gap&quot;</span><span class="p">][</span><span class="s2">&quot;outlier_flag&quot;</span><span class="p">]</span>
        <span class="n">gapsdf</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;gap&quot;</span>

        <span class="c1"># Remove gaps from df</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">gapsdf</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">overwrite_outliers_by_gaps_and_missing</span><span class="p">:</span>
            <span class="n">outliersdf</span> <span class="o">=</span> <span class="n">outliersdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">gapsdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># Remove gapfill values records from the gaps</span>
        <span class="n">gapsdf</span> <span class="o">=</span> <span class="n">gapsdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">gapsfilldf</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># =============================================================================</span>
        <span class="c1"># Stack missing</span>
        <span class="c1"># =============================================================================</span>
        <span class="n">missingfilldf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_fill_df</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">missingfilldf</span> <span class="o">=</span> <span class="n">value_labeled_doubleidxdf_to_triple_idxdf</span><span class="p">(</span>
            <span class="n">missingfilldf</span><span class="p">,</span> <span class="n">known_obstypes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">missingfilldf</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;missing observation fill&quot;</span>

        <span class="c1"># add missing observations if they occure in observation space</span>
        <span class="n">missingidx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">get_missing_indx_in_obs_space</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">missingdf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">missingidx</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="n">present_obstypes</span><span class="p">)</span>

        <span class="n">missingdf</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">missingdf</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">dropna</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>
            <span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;level_2&quot;</span><span class="p">:</span> <span class="s2">&quot;obstype&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;value&quot;</span><span class="p">})</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;obstype&quot;</span><span class="p">])</span>
        <span class="p">)</span>

        <span class="n">missingdf</span><span class="p">[</span><span class="s2">&quot;label&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_info&quot;</span><span class="p">][</span><span class="s2">&quot;missing_timestamp&quot;</span><span class="p">][</span>
            <span class="s2">&quot;outlier_flag&quot;</span>
        <span class="p">]</span>
        <span class="n">missingdf</span><span class="p">[</span><span class="s2">&quot;toolkit_representation&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;missing observation&quot;</span>

        <span class="c1"># Remove missing from df</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">missingdf</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">overwrite_outliers_by_gaps_and_missing</span><span class="p">:</span>
            <span class="n">outliersdf</span> <span class="o">=</span> <span class="n">outliersdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">missingdf</span><span class="o">.</span><span class="n">index</span><span class="p">,</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># Remove missingfill values records from the missing</span>
        <span class="n">missingdf</span> <span class="o">=</span> <span class="n">missingdf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">missingfilldf</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>

        <span class="c1"># =============================================================================</span>
        <span class="c1"># combine all</span>
        <span class="c1"># =============================================================================</span>

        <span class="n">combdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
            <span class="p">[</span><span class="n">df</span><span class="p">,</span> <span class="n">outliersdf</span><span class="p">,</span> <span class="n">gapsdf</span><span class="p">,</span> <span class="n">gapsfilldf</span><span class="p">,</span> <span class="n">missingdf</span><span class="p">,</span> <span class="n">missingfilldf</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="n">combdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;obstype&quot;</span><span class="p">]</span>
        <span class="c1"># To be shure?</span>
        <span class="n">combdf</span> <span class="o">=</span> <span class="n">combdf</span><span class="p">[</span><span class="o">~</span><span class="n">combdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">combdf</span></div>


<div class="viewcode-block" id="Dataset.get_qc_stats">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_qc_stats.html#metobs_toolkit.Dataset.get_qc_stats">[docs]</a>
    <span class="k">def</span> <span class="nf">get_qc_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obstype</span><span class="o">=</span><span class="s2">&quot;temp&quot;</span><span class="p">,</span> <span class="n">stationname</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">make_plot</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Get quality control statistics.</span>

<span class="sd">        Compute frequency statistics on the qc labels for an observationtype.</span>
<span class="sd">        The output is a dataframe containing the frequency statistics presented</span>
<span class="sd">        as percentages.</span>

<span class="sd">        These frequencies can also be presented as a collection of piecharts</span>
<span class="sd">        per check.</span>

<span class="sd">        With stationnames you can subset the data to one ore multiple stations.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        obstype : str, optional</span>
<span class="sd">            Observation type to analyse the QC labels on. The default is</span>
<span class="sd">            &#39;temp&#39;.</span>
<span class="sd">        stationname : str, optional</span>
<span class="sd">            Stationname to subset the quality labels on. If None, all</span>
<span class="sd">            stations are used. The default is None.</span>
<span class="sd">        make_plot : Bool, optional</span>
<span class="sd">            If True, a plot with piecharts is generated. The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        ---------</span>
<span class="sd">        dataset_qc_stats : pandas.DataFrame</span>
<span class="sd">            A table containing the label frequencies per check presented</span>
<span class="sd">            as percentages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># cobmine all and get final label</span>
        <span class="n">comb_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">combine_all_to_obsspace</span><span class="p">()</span>

        <span class="c1"># subset to relevant columnt</span>
        <span class="n">comb_df</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="n">comb_df</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;obstype&quot;</span><span class="p">)[[</span><span class="s2">&quot;label&quot;</span><span class="p">]]</span>

        <span class="c1"># subset to stationnames</span>
        <span class="k">if</span> <span class="n">stationname</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">stationname</span> <span class="ow">in</span> <span class="n">comb_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span>
                <span class="s2">&quot;name&quot;</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot; stationnames: </span><span class="si">{</span><span class="n">stationname</span><span class="si">}</span><span class="s2"> is not a list.&quot;</span>

            <span class="n">comb_df</span> <span class="o">=</span> <span class="n">comb_df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stationname</span><span class="p">]</span>

        <span class="c1"># compute freq statistics</span>
        <span class="n">final_freq</span><span class="p">,</span> <span class="n">outl_freq</span><span class="p">,</span> <span class="n">specific_freq</span> <span class="o">=</span> <span class="n">get_freq_statistics</span><span class="p">(</span>
            <span class="n">comb_df</span><span class="o">=</span><span class="n">comb_df</span><span class="p">,</span>
            <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>
            <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
            <span class="n">gaps_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_info&quot;</span><span class="p">],</span>
            <span class="n">applied_qc_order</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="nb">any</span><span class="p">([</span><span class="n">stat</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="p">[</span><span class="n">final_freq</span><span class="p">,</span> <span class="n">outl_freq</span><span class="p">,</span> <span class="n">specific_freq</span><span class="p">]]):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># make title</span>
        <span class="n">orig_obstype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">get_orig_name</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">stationname</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Label frequency statistics on all stations for </span><span class="si">{</span><span class="n">orig_obstype</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">title</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Label frequency statistics for </span><span class="si">{</span><span class="n">stationname</span><span class="si">}</span><span class="s2"> for </span><span class="si">{</span><span class="n">orig_obstype</span><span class="si">}</span><span class="s2">.&quot;</span>

        <span class="k">if</span> <span class="n">make_plot</span><span class="p">:</span>
            <span class="c1"># make pie plots</span>
            <span class="n">qc_stats_pie</span><span class="p">(</span>
                <span class="n">final_stats</span><span class="o">=</span><span class="n">final_freq</span><span class="p">,</span>
                <span class="n">outlier_stats</span><span class="o">=</span><span class="n">outl_freq</span><span class="p">,</span>
                <span class="n">specific_stats</span><span class="o">=</span><span class="n">specific_freq</span><span class="p">,</span>
                <span class="n">plot_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;plot_settings&quot;</span><span class="p">],</span>
                <span class="n">qc_check_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
                <span class="n">title</span><span class="o">=</span><span class="n">title</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">final_freq</span><span class="p">,</span> <span class="n">outl_freq</span><span class="p">,</span> <span class="n">specific_freq</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">update_outliersdf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">add_to_outliersdf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the outliersdf attribute.&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="p">,</span> <span class="n">add_to_outliersdf</span><span class="p">])</span>

<div class="viewcode-block" id="Dataset.coarsen_time_resolution">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.coarsen_time_resolution.html#metobs_toolkit.Dataset.coarsen_time_resolution">[docs]</a>
    <span class="k">def</span> <span class="nf">coarsen_time_resolution</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">origin_tz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Resample the observations to coarser timeresolution.</span>

<span class="sd">        The assumed dataset resolution (stored in the metadf attribute) will be</span>
<span class="sd">        updated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        origin : datetime.datetime, optional</span>
<span class="sd">            Define the origin (first timestamp) for the obervations. The origin</span>
<span class="sd">            is timezone naive, and is assumed to have the same timezone as the</span>
<span class="sd">            obervations. If None, the earliest occuring timestamp is used as</span>
<span class="sd">            origin. The default is None.</span>
<span class="sd">        origin_tz : str, optional</span>
<span class="sd">            Timezone string of the input observations. Element of</span>
<span class="sd">            pytz.all_timezones. If None, the timezone from the settings is</span>
<span class="sd">            used. The default is None.</span>
<span class="sd">        freq : DateOffset, Timedelta or str, optional</span>
<span class="sd">            The offset string or object representing target conversion.</span>
<span class="sd">            Ex: &#39;15T&#39; is 15 minuts, &#39;1H&#39;, is one hour. If None, the target time</span>
<span class="sd">            resolution of the dataset.settings is used. The default is None.</span>
<span class="sd">        method : &#39;nearest&#39; or &#39;bfill&#39;, optional</span>
<span class="sd">            Method to apply for the resampling. If None, the resample method of</span>
<span class="sd">            the dataset.settings is used. The default is None.</span>
<span class="sd">        limit : int, optional</span>
<span class="sd">            Limit of how many values to fill with one original observations. If</span>
<span class="sd">            None, the target limit of the dataset.settings is used. The default</span>
<span class="sd">            is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">freq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;target_time_res&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;resample_method&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">limit</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">limit</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;resample_limit&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">origin_tz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin_tz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Coarsening the timeresolution to </span><span class="si">{</span><span class="n">freq</span><span class="si">}</span><span class="s2"> using </span><span class="se">\</span>
<span class="s2">                    the </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">-method (with limit=</span><span class="si">{</span><span class="n">limit</span><span class="si">}</span><span class="s2">).&quot;</span>
        <span class="p">)</span>

        <span class="c1"># test if coarsening the resolution is valid for the dataset</span>
        <span class="c1"># 1. If resolution-dep-qc is applied --&gt; coarsening is not valid and will result in a broken dataset</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">[</span>
                <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">[</span><span class="s2">&quot;checkname&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span>
                    <span class="p">[</span><span class="s2">&quot;duplicated_timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;invalid_input&quot;</span><span class="p">]</span>
                <span class="p">)</span>
            <span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="o">&gt;</span> <span class="mi">0</span>
        <span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Coarsening time resolution is not possible because quality control checks that are resolution depening are already performed on the Dataset.&quot;</span>
            <span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;(Apply coarsening_time_resolution BEFORE applying quality control.)&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># TODO: implement buffer method</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># find earlyest timestamp, if it is on the hour, use it else use the following hour</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">tstart</span><span class="o">.</span><span class="n">minute</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tstart</span><span class="o">.</span><span class="n">second</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">tstart</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Round up to nearest hour</span>
                <span class="n">tstart</span> <span class="o">=</span> <span class="n">tstart</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">freq</span><span class="o">=</span><span class="n">freq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">origin_tz_aware</span> <span class="o">=</span> <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="n">origin_tz</span><span class="p">)</span><span class="o">.</span><span class="n">localize</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
            <span class="n">tstart</span> <span class="o">=</span> <span class="n">origin_tz_aware</span><span class="o">.</span><span class="n">astimezone</span><span class="p">(</span>
                <span class="n">pytz</span><span class="o">.</span><span class="n">timezone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">])</span>
            <span class="p">)</span>

        <span class="c1"># Coarsen timeresolution</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;nearest&quot;</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">tstart</span><span class="p">)</span>
                <span class="o">.</span><span class="n">nearest</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bfill&quot;</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>
                <span class="o">.</span><span class="n">resample</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="n">tstart</span><span class="p">)</span>
                <span class="o">.</span><span class="n">bfill</span><span class="p">(</span><span class="n">limit</span><span class="o">=</span><span class="n">limit</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The coarsening method: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">, is not implemented yet.&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>

        <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">])</span>

        <span class="c1"># Update resolution info in metadf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span>
        <span class="c1"># update df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>

        <span class="c1"># Remove gaps and missing from the observatios</span>
        <span class="c1"># most gaps and missing are already removed but when increasing timeres,</span>
        <span class="c1"># some records should be removed as well.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">remove_gaps_from_obs</span><span class="p">(</span><span class="n">gaplist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">,</span> <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">remove_missing_from_obs</span><span class="p">(</span><span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span></div>


<div class="viewcode-block" id="Dataset.sync_observations">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.sync_observations.html#metobs_toolkit.Dataset.sync_observations">[docs]</a>
    <span class="k">def</span> <span class="nf">sync_observations</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">tollerance</span><span class="p">,</span>
        <span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">_force_resolution_minutes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">_drop_target_nan_dt</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simplify and syncronize the observation timestamps.</span>

<span class="sd">        To simplify the resolution (per station), a tollerance is use to shift timestamps. The tollerance indicates the</span>
<span class="sd">        maximum translation in time that can be applied to an observation.</span>

<span class="sd">        The sycronisation tries to group stations that have an equal simplified resolution, and syncronize them. The origin</span>
<span class="sd">        of the sycronized timestamps will be set to round hours, round 10-minutes or round-5 minutes if possible given the tollerance.</span>

<span class="sd">        The observations present in the input file are used.</span>

<span class="sd">        After syncronization, the IO outliers, missing observations and gaps are recomputed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        tollerance :  Timedelta or str</span>
<span class="sd">            The tollerance string or object representing the maximum translation in time.</span>
<span class="sd">            Ex: &#39;5T&#39; is 5 minuts, &#39;1H&#39;, is one hour.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, a dataframe illustrating the mapping from original datetimes to simplified and syncronized is returned. The default is True.</span>
<span class="sd">        _drop_target_nan_dt : bool, optional</span>
<span class="sd">            If record has no target datetime, the datetimes will be listed as Nat. To remove them,</span>
<span class="sd">            set this to True. Default is False.</span>
<span class="sd">        _force_resolution_minutes : bool, optional</span>
<span class="sd">            force the resolution estimate to this frequency in minutes. If None, the frequency is estimated. The default is None.</span>
<span class="sd">        Note</span>
<span class="sd">        --------</span>
<span class="sd">        Keep in mind that this method will overwrite the df, outliersdf, missing timestamps and gaps.</span>

<span class="sd">        Note</span>
<span class="sd">        --------</span>
<span class="sd">        Because the used observations are from the input file, previously coarsend timeresolutions are ignored.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        pandas.DataFrame (if verbose is True)</span>
<span class="sd">            A dataframe containing the original observations with original timestamps and the corresponding target timestamps.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get columns pressent in metadf, because the input df can have columns</span>
        <span class="c1"># that does not have to be mapped to the toolkit</span>

        <span class="k">assert</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_df</span><span class="o">.</span><span class="n">empty</span>
        <span class="p">),</span> <span class="s2">&quot;To syncronize a dataset, the (pure) input dataframe cannot be empty.&quot;</span>

        <span class="n">init_meta_cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_df</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">init_multiindexdf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="n">init_triple_multiindexdf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gapfilldf</span> <span class="o">=</span> <span class="n">init_multiindexdf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># find simplified resolution</span>
        <span class="k">if</span> <span class="n">_force_resolution_minutes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">simplified_resolution</span> <span class="o">=</span> <span class="n">get_freqency_series</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;median&quot;</span><span class="p">,</span> <span class="n">simplify</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_simplify_error</span><span class="o">=</span><span class="n">tollerance</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">_force_resolution_minutes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># TODO</span>
                <span class="nb">print</span><span class="p">(</span>
                    <span class="s2">&quot;foce resolution minutes as a list is not implemented yet, sorry.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stations</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span>
                <span class="n">freq_series</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span>
                    <span class="n">index</span><span class="o">=</span><span class="n">stations</span><span class="p">,</span>
                    <span class="n">data</span><span class="o">=</span><span class="p">[</span><span class="n">timedelta</span><span class="p">(</span><span class="n">minutes</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">_force_resolution_minutes</span><span class="p">))]</span>
                    <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">stations</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="n">simplified_resolution</span> <span class="o">=</span> <span class="n">freq_series</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Syncronizing to these resolutions: </span><span class="si">{</span><span class="n">simplified_resolution</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="n">occuring_resolutions</span> <span class="o">=</span> <span class="n">simplified_resolution</span><span class="o">.</span><span class="n">unique</span><span class="p">()</span>

        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">find_simple_origin</span><span class="p">(</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tollerance</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">tstart</span><span class="o">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tstart</span><span class="o">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tstart</span><span class="o">.</span><span class="n">microsecond</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">tstart</span>  <span class="c1"># already a round hour</span>

            <span class="c1"># try converting to a round hour</span>
            <span class="n">tstart_round_hour</span> <span class="o">=</span> <span class="n">tstart</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s2">&quot;60min&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tstart</span> <span class="o">-</span> <span class="n">tstart_round_hour</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">tollerance</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">tstart_round_hour</span>

            <span class="c1"># try converting to a tenfold in minutes</span>
            <span class="n">tstart_round_tenfold</span> <span class="o">=</span> <span class="n">tstart</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s2">&quot;10min&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tstart</span> <span class="o">-</span> <span class="n">tstart_round_tenfold</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">tollerance</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">tstart_round_tenfold</span>

            <span class="c1"># try converting to a fivefold in minutes</span>
            <span class="n">tstart_round_fivefold</span> <span class="o">=</span> <span class="n">tstart</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="s2">&quot;5min&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">tstart</span> <span class="o">-</span> <span class="n">tstart_round_fivefold</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">tollerance</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">tstart_round_fivefold</span>

            <span class="c1"># no suitable conversion found</span>
            <span class="k">return</span> <span class="n">tstart</span>

        <span class="n">merged_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">_total_verbose_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">occur_res</span> <span class="ow">in</span> <span class="n">occuring_resolutions</span><span class="p">:</span>
            <span class="n">group_stations</span> <span class="o">=</span> <span class="n">simplified_resolution</span><span class="p">[</span>
                <span class="n">simplified_resolution</span> <span class="o">==</span> <span class="n">occur_res</span>
            <span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot; Grouping stations with simplified resolution of </span><span class="si">{</span><span class="n">pd</span><span class="o">.</span><span class="n">to_timedelta</span><span class="p">(</span><span class="n">occur_res</span><span class="p">)</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">group_stations</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="n">groupdf</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">group_stations</span><span class="p">)]</span>

            <span class="n">tstart</span> <span class="o">=</span> <span class="n">groupdf</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
            <span class="n">tend</span> <span class="o">=</span> <span class="n">groupdf</span><span class="p">[</span><span class="s2">&quot;datetime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

            <span class="c1"># find a good origin point</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">find_simple_origin</span><span class="p">(</span><span class="n">tstart</span><span class="o">=</span><span class="n">tstart</span><span class="p">,</span> <span class="n">tollerance</span><span class="o">=</span><span class="n">tollerance</span><span class="p">)</span>

            <span class="c1"># Create records index</span>
            <span class="n">target_records</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">date_range</span><span class="p">(</span>
                <span class="n">start</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="n">tend</span><span class="p">,</span> <span class="n">freq</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">occur_res</span><span class="p">)</span>
            <span class="p">)</span><span class="o">.</span><span class="n">to_series</span><span class="p">()</span>

            <span class="n">target_records</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;target_datetime&quot;</span>
            <span class="c1"># convert records to new target records, station per station</span>

            <span class="k">for</span> <span class="n">sta</span> <span class="ow">in</span> <span class="n">group_stations</span><span class="p">:</span>
                <span class="n">stadf</span> <span class="o">=</span> <span class="n">groupdf</span><span class="p">[</span><span class="n">groupdf</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">sta</span><span class="p">]</span>
                <span class="c1"># Drop all nan values! these will be added later from the outliersdf</span>
                <span class="n">stadf</span> <span class="o">=</span> <span class="n">stadf</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>

                <span class="c1"># drop all records per statiotion for which there are no obsecvations</span>
                <span class="n">present_obs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

                <span class="n">stadf</span> <span class="o">=</span> <span class="n">stadf</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">stadf</span><span class="p">[</span><span class="n">present_obs</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">index</span><span class="p">]</span>

                <span class="n">stadf</span> <span class="o">=</span> <span class="n">stadf</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span>

                <span class="n">mergedstadf</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge_asof</span><span class="p">(</span>
                    <span class="n">left</span><span class="o">=</span><span class="n">stadf</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">),</span>
                    <span class="n">right</span><span class="o">=</span><span class="n">target_records</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(),</span>
                    <span class="n">right_on</span><span class="o">=</span><span class="s2">&quot;target_datetime&quot;</span><span class="p">,</span>
                    <span class="n">left_on</span><span class="o">=</span><span class="s2">&quot;datetime&quot;</span><span class="p">,</span>
                    <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;nearest&quot;</span><span class="p">,</span>
                    <span class="n">tolerance</span><span class="o">=</span><span class="n">pd</span><span class="o">.</span><span class="n">Timedelta</span><span class="p">(</span><span class="n">tollerance</span><span class="p">),</span>
                <span class="p">)</span>
                <span class="k">if</span> <span class="n">_drop_target_nan_dt</span><span class="p">:</span>
                    <span class="n">mergedstadf</span> <span class="o">=</span> <span class="n">mergedstadf</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="s2">&quot;target_datetime&quot;</span><span class="p">)</span>
                <span class="c1"># possibility 1: record is mapped crrectly</span>
                <span class="n">correct_mapped</span> <span class="o">=</span> <span class="n">mergedstadf</span><span class="p">[</span><span class="o">~</span><span class="n">mergedstadf</span><span class="p">[</span><span class="s2">&quot;target_datetime&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isnull</span><span class="p">()]</span>

                <span class="c1"># possibility2: records that ar not mapped to target</span>
                <span class="c1"># not_mapped_records =mergedstadf[mergedstadf[&#39;target_datetime&#39;].isnull()]</span>

                <span class="c1"># possibilyt 3 : no suitable candidates found for the target</span>
                <span class="c1"># these will be cached by the missing and gap check</span>
                <span class="c1"># no_record_candidates = target_records[~target_records.isin(mergedstadf[&#39;target_datetime&#39;])].values</span>

                <span class="n">merged_df</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="n">merged_df</span><span class="p">,</span> <span class="n">correct_mapped</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                    <span class="n">_total_verbose_df</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">([</span><span class="n">_total_verbose_df</span><span class="p">,</span> <span class="n">mergedstadf</span><span class="p">])</span>

        <span class="c1"># overwrite the df with the synced observations</span>
        <span class="n">merged_df</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">merged_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;datetime&quot;</span><span class="p">:</span> <span class="s2">&quot;original_datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;target_datetime&quot;</span><span class="p">:</span> <span class="s2">&quot;datetime&quot;</span><span class="p">}</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>
            <span class="o">.</span><span class="n">drop</span><span class="p">([</span><span class="s2">&quot;original_datetime&quot;</span><span class="p">],</span> <span class="n">errors</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>
        <span class="p">)</span>
        <span class="c1"># self.df = merged_df</span>

        <span class="c1"># Recompute the dataset attributes, apply qc, gap and missing searches, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_dataset</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">merged_df</span><span class="p">,</span>
            <span class="n">freq_estimation_method</span><span class="o">=</span><span class="s2">&quot;highest&quot;</span><span class="p">,</span>
            <span class="n">freq_estimation_simplify</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">freq_estimation_simplify_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">fixed_freq_series</span><span class="o">=</span><span class="n">simplified_resolution</span><span class="p">,</span>
            <span class="n">update_full_metadf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>  <span class="c1"># Do not overwrite full metadf, only the frequencies</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span>
            <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">init_meta_cols</span><span class="p">]</span>
        <span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="n">_total_verbose_df</span> <span class="o">=</span> <span class="n">_total_verbose_df</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="n">columns</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;datetime&quot;</span><span class="p">:</span> <span class="s2">&quot;original_datetime&quot;</span><span class="p">,</span> <span class="s2">&quot;target_datetime&quot;</span><span class="p">:</span> <span class="s2">&quot;datetime&quot;</span><span class="p">}</span>
            <span class="p">)</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">_total_verbose_df</span></div>


<div class="viewcode-block" id="Dataset.import_data_from_file">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.import_data_from_file.html#metobs_toolkit.Dataset.import_data_from_file">[docs]</a>
    <span class="k">def</span> <span class="nf">import_data_from_file</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">long_format</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="n">obstype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">obstype_unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">obstype_description</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq_estimation_method</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq_estimation_simplify</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">freq_estimation_simplify_error</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">kwargs_data_read</span><span class="o">=</span><span class="p">{},</span>
        <span class="n">kwargs_metadata_read</span><span class="o">=</span><span class="p">{},</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read observations from a csv file.</span>

<span class="sd">        The paths are defined in the Settings.input_file. The input file</span>
<span class="sd">        columns should have a template that is stored in</span>
<span class="sd">        Settings.template_list.</span>

<span class="sd">        If the metadata is stored in a seperate file, and the</span>
<span class="sd">        Settings.input_metadata_file is correct, than this metadata is also</span>
<span class="sd">        imported (if a suitable template is in the Settings.template_list.)</span>

<span class="sd">        The dataset is by default assumed to be in long-format (each column represent an observation type, one column indicates the stationname).</span>
<span class="sd">        Wide-format can be used if</span>

<span class="sd">        - the &#39;wide&#39; option is present in the template (this is done automatically if the themplate was made using the metobs_toolkit.build_template_prompt())</span>

<span class="sd">        - &#39;long_format&#39; is set to False and if the observation type is specified (obstype, obstype_unit and obstype_description)</span>

<span class="sd">        An estimation of the observational frequency is made per station. This is used</span>
<span class="sd">        to find missing observations and gaps.</span>


<span class="sd">        The Dataset attributes are set and the following checks are executed:</span>
<span class="sd">                * Duplicate check</span>
<span class="sd">                * Invalid input check</span>
<span class="sd">                * Find missing observations</span>
<span class="sd">                * Find gaps</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        long_format : bool, optional</span>
<span class="sd">            True if the inputdata has a long-format, False if it has a wide-format. The default is True.</span>
<span class="sd">        obstype : str, optional</span>
<span class="sd">            If the dataformat is wide, specify which observation type the</span>
<span class="sd">            observations represent. The obstype should be an element of</span>
<span class="sd">            metobs_toolkit.observation_types. The default is None.</span>
<span class="sd">        obstype_unit : str, optional</span>
<span class="sd">            If the dataformat is wide, specify the unit of the obstype. The</span>
<span class="sd">            default is None.</span>
<span class="sd">        obstype_description : str, optional</span>
<span class="sd">            If the dataformat is wide, specify the description of the obstype.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        freq_estimation_method : &#39;highest&#39; or &#39;median&#39;, optional</span>
<span class="sd">            Select wich method to use for the frequency estimation. If</span>
<span class="sd">            &#39;highest&#39;, the highest apearing frequency is used. If &#39;median&#39;, the</span>
<span class="sd">            median of the apearing frequencies is used. If None, the method</span>
<span class="sd">            stored in the</span>
<span class="sd">            Dataset.settings.time_settings[&#39;freq_estimation_method&#39;] is used.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        freq_estimation_simplify : bool, optional</span>
<span class="sd">            If True, the likely frequency is converted to round hours, or round minutes.</span>
<span class="sd">            The &quot;freq_estimation_simplify_error&#39; is used as a constrain. If the constrain is not met,</span>
<span class="sd">            the simplification is not performed. If None, the method</span>
<span class="sd">            stored in the</span>
<span class="sd">            Dataset.settings.time_settings[&#39;freq_estimation_simplify&#39;] is used.</span>
<span class="sd">            The default is None.</span>
<span class="sd">        freq_estimation_simplify_error : Timedelta or str, optional</span>
<span class="sd">            The tollerance string or object representing the maximum translation in time to form a simplified frequency estimation.</span>
<span class="sd">            Ex: &#39;5T&#39; is 5 minuts, &#39;1H&#39;, is one hour. If None, the method</span>
<span class="sd">            stored in the</span>
<span class="sd">            Dataset.settings.time_settings[&#39;freq_estimation_simplify_error&#39;] is</span>
<span class="sd">            used. The default is None.</span>
<span class="sd">        kwargs_data_read : dict, optional</span>
<span class="sd">            Keyword arguments collected in a dictionary to pass to the</span>
<span class="sd">            pandas.read_csv() function on the data file. The default is {}.</span>
<span class="sd">        kwargs_metadata_read : dict, optional</span>
<span class="sd">            Keyword arguments collected in a dictionary to pass to the</span>
<span class="sd">            pandas.read_csv() function on the metadata file. The default is {}.</span>

<span class="sd">        Note</span>
<span class="sd">        --------</span>
<span class="sd">        If options are present in the template, these will have priority over the arguments of this function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Importing data from file: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;input_data_file&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">freq_estimation_method</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="n">freq_estimation_method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span>
                <span class="s2">&quot;freq_estimation_method&quot;</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">freq_estimation_simplify</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq_estimation_simplify</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span>
                <span class="s2">&quot;freq_estimation_simplify&quot;</span>
            <span class="p">]</span>
        <span class="k">if</span> <span class="n">freq_estimation_simplify_error</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq_estimation_simplify_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span>
                <span class="s2">&quot;freq_estimation_simplify_error&quot;</span>
            <span class="p">]</span>

        <span class="c1"># check if obstype is valid</span>
        <span class="k">if</span> <span class="n">obstype</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">obstype</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> is not a known observation type. Use one of the default, or add a new to the defaults: </span><span class="si">{</span><span class="n">tlk_obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="si">}</span><span class="s2">.&quot;</span>

        <span class="c1"># Read template</span>
        <span class="n">template</span><span class="p">,</span> <span class="n">options_kwargs</span> <span class="o">=</span> <span class="n">read_csv_template</span><span class="p">(</span>
            <span class="n">file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">templates</span><span class="p">[</span><span class="s2">&quot;template_file&quot;</span><span class="p">],</span>
            <span class="n">known_obstypes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">data_long_format</span><span class="o">=</span><span class="n">long_format</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># update the kwargs using the option kwargs (i.g. arguments from in the template)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Options found in the template: </span><span class="si">{</span><span class="n">options_kwargs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;long_format&quot;</span> <span class="ow">in</span> <span class="n">options_kwargs</span><span class="p">:</span>
            <span class="n">long_format</span> <span class="o">=</span> <span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;long_format&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Set long_format = </span><span class="si">{</span><span class="n">long_format</span><span class="si">}</span><span class="s2"> from options in template.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;obstype&quot;</span> <span class="ow">in</span> <span class="n">options_kwargs</span><span class="p">:</span>
            <span class="n">obstype</span> <span class="o">=</span> <span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Set obstype = </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> from options in template.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;obstype_unit&quot;</span> <span class="ow">in</span> <span class="n">options_kwargs</span><span class="p">:</span>
            <span class="n">obstype_unit</span> <span class="o">=</span> <span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;obstype_unit&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Set obstype_unit = </span><span class="si">{</span><span class="n">obstype_unit</span><span class="si">}</span><span class="s2"> from options in template.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;obstype_description&quot;</span> <span class="ow">in</span> <span class="n">options_kwargs</span><span class="p">:</span>
            <span class="n">obstype_description</span> <span class="o">=</span> <span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;obstype_description&quot;</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Set obstype description = </span><span class="si">{</span><span class="n">obstype_description</span><span class="si">}</span><span class="s2"> from options in template.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;single&quot;</span> <span class="ow">in</span> <span class="n">options_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_default_name</span><span class="p">(</span><span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;single&quot;</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Set single station name = </span><span class="si">{</span><span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;single&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> from options in template.&#39;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;timezone&quot;</span> <span class="ow">in</span> <span class="n">options_kwargs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_timezone</span><span class="p">(</span><span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">])</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Set timezone = </span><span class="si">{</span><span class="n">options_kwargs</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> from options in template.&#39;</span>
            <span class="p">)</span>

        <span class="c1"># Read observations into pandas dataframe</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">template</span> <span class="o">=</span> <span class="n">import_data_from_csv</span><span class="p">(</span>
            <span class="n">input_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;input_data_file&quot;</span><span class="p">],</span>
            <span class="n">template</span><span class="o">=</span><span class="n">template</span><span class="p">,</span>
            <span class="n">long_format</span><span class="o">=</span><span class="n">long_format</span><span class="p">,</span>
            <span class="n">obstype</span><span class="o">=</span><span class="n">obstype</span><span class="p">,</span>  <span class="c1"># only relevant in wide format</span>
            <span class="n">obstype_units</span><span class="o">=</span><span class="n">obstype_unit</span><span class="p">,</span>  <span class="c1"># only relevant in wide format</span>
            <span class="n">obstype_description</span><span class="o">=</span><span class="n">obstype_description</span><span class="p">,</span>  <span class="c1"># only relevant in wide format</span>
            <span class="n">known_obstypes</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
            <span class="n">kwargs_data_read</span><span class="o">=</span><span class="n">kwargs_data_read</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Set timezone information</span>
        <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tz_localize</span><span class="p">(</span>
            <span class="n">tz</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">time_settings</span><span class="p">[</span><span class="s2">&quot;timezone&quot;</span><span class="p">],</span>
            <span class="n">ambiguous</span><span class="o">=</span><span class="s2">&quot;infer&quot;</span><span class="p">,</span>
            <span class="n">nonexistent</span><span class="o">=</span><span class="s2">&quot;shift_forward&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># drop Nat datetimes if present</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">notnull</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">)]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
            <span class="sa">f</span><span class="s1">&#39;Data from </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;input_data_file&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> </span><span class="se">\</span>
<span class="s1">                     imported to dataframe </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="s1">.&#39;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;input_metadata_file&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;No metadata file is defined,</span><span class="se">\</span>
<span class="s2">                    no metadata attributes can be set!&quot;</span>
            <span class="p">)</span>

            <span class="c1"># if no metadata is given, and no stationname found, assume one station</span>
            <span class="c1"># with default name</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s1">&#39;No station names find in the observations! Assume the dataset is for ONE</span><span class="se">\</span>
<span class="s1">station with the default name: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span>
                <span class="p">)</span>
                <span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Importing metadata from file: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;input_metadata_file&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="n">meta_df</span> <span class="o">=</span> <span class="n">import_metadata_from_csv</span><span class="p">(</span>
                <span class="n">input_file</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;input_metadata_file&quot;</span><span class="p">],</span>
                <span class="n">template</span><span class="o">=</span><span class="n">template</span><span class="p">,</span>
                <span class="n">kwargs_metadata_read</span><span class="o">=</span><span class="n">kwargs_metadata_read</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># in dataset of one station, the name is most often not present!</span>
            <span class="k">if</span> <span class="s2">&quot;name&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No station names find in the observations!&quot;</span><span class="p">)</span>

                <span class="c1"># If there is ONE name in the metadf, than we use that name for</span>
                <span class="c1"># the df, else we use the default name</span>
                <span class="k">if</span> <span class="p">(</span><span class="s2">&quot;name&quot;</span> <span class="ow">in</span> <span class="n">meta_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">meta_df</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="n">meta_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">name</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;One stationname found in the metadata: </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">, this name is used for the data.&quot;</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">])</span>
                    <span class="c1"># for later merging, we add the name column with the default</span>
                    <span class="c1"># also in the metadf</span>
                    <span class="n">meta_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">])</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s1">&#39;Assume the dataset is for ONE station with the </span><span class="se">\</span>
<span class="s1">                        default name: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;default_name&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1">.&#39;</span>
                    <span class="p">)</span>

            <span class="c1"># make shure name column in metadata and data have the same type for merging</span>
            <span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
            <span class="n">meta_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">meta_df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>

            <span class="c1"># merge additional metadata to observations</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Head of data file, before merge: </span><span class="si">{</span><span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Head of metadata file, before merge: </span><span class="si">{</span><span class="n">meta_df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

            <span class="n">meta_cols</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">colname</span> <span class="k">for</span> <span class="n">colname</span> <span class="ow">in</span> <span class="n">meta_df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">colname</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;_&quot;</span><span class="p">)</span>
            <span class="p">]</span>
            <span class="n">additional_meta_cols</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">meta_cols</span><span class="p">)</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">))</span>

            <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">additional_meta_cols</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Merging metadata (</span><span class="si">{</span><span class="n">additional_meta_cols</span><span class="si">}</span><span class="s2">) to dataset data by name.&quot;</span>
                <span class="p">)</span>
                <span class="n">additional_meta_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span>  <span class="c1"># merging on name</span>
                <span class="c1"># merge deletes datetime index somehow? so add it back.</span>
                <span class="n">df_index</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
                    <span class="n">right</span><span class="o">=</span><span class="n">meta_df</span><span class="p">[</span><span class="n">additional_meta_cols</span><span class="p">],</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s2">&quot;name&quot;</span>
                <span class="p">)</span>
                <span class="n">df</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">df_index</span>

        <span class="c1"># update dataset object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">template</span><span class="p">)</span>

        <span class="c1"># Remove stations whith only one observation (no freq estimation)</span>
        <span class="n">station_counts</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
        <span class="n">issue_station</span> <span class="o">=</span> <span class="n">station_counts</span><span class="p">[</span><span class="n">station_counts</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">to_list</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;These stations will be removed because of only having one record: </span><span class="si">{</span><span class="n">issue_station</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="n">df</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">issue_station</span><span class="p">)]</span>

        <span class="c1"># convert dataframe to multiindex (datetime - name)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">])</span>

        <span class="c1"># Sort by name and then by datetime (to avoid negative freq)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>

        <span class="c1"># dataframe with all data of input file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;datetime&quot;</span><span class="p">])</span>
        <span class="c1"># Construct all attributes of the Dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_construct_dataset</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="n">df</span><span class="p">,</span>
            <span class="n">freq_estimation_method</span><span class="o">=</span><span class="n">freq_estimation_method</span><span class="p">,</span>
            <span class="n">freq_estimation_simplify</span><span class="o">=</span><span class="n">freq_estimation_simplify</span><span class="p">,</span>
            <span class="n">freq_estimation_simplify_error</span><span class="o">=</span><span class="n">freq_estimation_simplify_error</span><span class="p">,</span>
        <span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_construct_dataset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">df</span><span class="p">,</span>
        <span class="n">freq_estimation_method</span><span class="p">,</span>
        <span class="n">freq_estimation_simplify</span><span class="p">,</span>
        <span class="n">freq_estimation_simplify_error</span><span class="p">,</span>
        <span class="n">fixed_freq_series</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">update_full_metadf</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Construct the Dataset class from a IO dataframe.</span>

<span class="sd">        The df, metadf, outliersdf, gaps, missing timestamps and observationtypes attributes are set.</span>


<span class="sd">        The observations are converted to the toolkit standard units if possible.</span>

<span class="sd">        Qc on IO is applied (duplicated check and invalid check) + gaps and missing</span>
<span class="sd">        values are defined by assuming a frequency per station.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        df : pandas.dataframe</span>
<span class="sd">            The dataframe containing the input observations and metadata.</span>
<span class="sd">        freq_estimation_method : &#39;highest&#39; or &#39;median&#39;</span>
<span class="sd">            Select wich method to use for the frequency estimation. If</span>
<span class="sd">            &#39;highest&#39;, the highest apearing frequency is used. If &#39;median&#39;, the</span>
<span class="sd">            median of the apearing frequencies is used.</span>
<span class="sd">        freq_estimation_simplify : bool</span>
<span class="sd">            If True, the likely frequency is converted to round hours, or round minutes.</span>
<span class="sd">            The &quot;freq_estimation_simplify_error&#39; is used as a constrain. If the constrain is not met,</span>
<span class="sd">            the simplification is not performed.</span>
<span class="sd">        freq_estimation_simplify_error : Timedelta or str, optional</span>
<span class="sd">            The tollerance string or object representing the maximum translation in time to form a simplified frequency estimation.</span>
<span class="sd">            Ex: &#39;5T&#39; is 5 minuts, &#39;1H&#39;, is one hour.</span>
<span class="sd">        fixed_freq_series : pandas.series or None, optional</span>
<span class="sd">            If you do not want the frequencies to be recalculated, one can pass the</span>
<span class="sd">            frequency series to update the metadf[&quot;dataset_resolution&quot;]. If None, the frequencies will be estimated. The default is None.</span>
<span class="sd">        update_full_metadf : bool, optional</span>
<span class="sd">            If True, the full Dataset.metadf will be updated. If False, only the frequency columns in the Dataset.metadf will be updated. The default is True.</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Convert dataframe to dataset attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_initiate_df_attribute</span><span class="p">(</span><span class="n">dataframe</span><span class="o">=</span><span class="n">df</span><span class="p">,</span> <span class="n">update_metadf</span><span class="o">=</span><span class="n">update_full_metadf</span><span class="p">)</span>

        <span class="c1"># Check observation types and convert units if needed.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_of_obstypes_and_units</span><span class="p">()</span>

        <span class="c1"># Apply quality control on Import resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_apply_qc_on_import</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">fixed_freq_series</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">freq_series</span> <span class="o">=</span> <span class="n">get_freqency_series</span><span class="p">(</span>
                <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
                <span class="n">method</span><span class="o">=</span><span class="n">freq_estimation_method</span><span class="p">,</span>
                <span class="n">simplify</span><span class="o">=</span><span class="n">freq_estimation_simplify</span><span class="p">,</span>
                <span class="n">max_simplify_error</span><span class="o">=</span><span class="n">freq_estimation_simplify_error</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">freq_series_import</span> <span class="o">=</span> <span class="n">freq_series</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;assumed_import_frequency&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="n">freq_series_import</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span>
                    <span class="s2">&quot;assumed_import_frequency&quot;</span>
                <span class="p">]</span>  <span class="c1"># No update</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">freq_series_import</span> <span class="o">=</span> <span class="n">fixed_freq_series</span>
            <span class="n">freq_series</span> <span class="o">=</span> <span class="n">fixed_freq_series</span>

        <span class="c1"># add import frequencies to metadf (after import qc!)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;assumed_import_frequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_series_import</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="s2">&quot;dataset_resolution&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq_series</span>

        <span class="c1"># Remove gaps and missing from the observations AFTER timecoarsening</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">remove_gaps_from_obs</span><span class="p">(</span><span class="n">gaplist</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">gaps</span><span class="p">,</span> <span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="o">.</span><span class="n">remove_missing_from_obs</span><span class="p">(</span><span class="n">obsdf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_initiate_df_attribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dataframe</span><span class="p">,</span> <span class="n">update_metadf</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize dataframe attributes.&quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Updating dataset by dataframe with shape: </span><span class="si">{</span><span class="n">dataframe</span><span class="o">.</span><span class="n">shape</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

        <span class="c1"># Create dataframe with fixed order of observational columns</span>
        <span class="n">obs_col_order</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">dataframe</span><span class="p">[</span><span class="n">obs_col_order</span><span class="p">]</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">update_metadf</span><span class="p">:</span>
            <span class="c1"># create metadataframe with fixed number and order of columns</span>
            <span class="n">metadf</span> <span class="o">=</span> <span class="n">dataframe</span><span class="o">.</span><span class="n">reindex</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">app</span><span class="p">[</span><span class="s2">&quot;location_info&quot;</span><span class="p">])</span>
            <span class="n">metadf</span><span class="o">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">droplevel</span><span class="p">(</span><span class="s2">&quot;datetime&quot;</span><span class="p">)</span>  <span class="c1"># drop datetimeindex</span>
            <span class="c1"># drop dubplicates due to datetime</span>
            <span class="n">metadf</span> <span class="o">=</span> <span class="n">metadf</span><span class="p">[</span><span class="o">~</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">duplicated</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="s2">&quot;first&quot;</span><span class="p">)]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="n">metadf_to_gdf</span><span class="p">(</span><span class="n">metadf</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_apply_qc_on_import</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># if the name is Nan, remove these records from df, and metadf (before)</span>
        <span class="c1"># they end up in the gaps and missing obs</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s1">&#39;Following observations are not linked to a station name and will be removed: </span><span class="si">{</span><span class="n">xs_save</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span><span class="w"> </span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Following station will be removed from the Dataset </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">isna</span><span class="p">()]</span>

        <span class="c1"># find missing obs and gaps, and remove them from the df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">missing_obs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gaps</span> <span class="o">=</span> <span class="n">missing_timestamp_and_gap_check</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">gapsize_n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gap</span><span class="p">[</span><span class="s2">&quot;gaps_settings&quot;</span><span class="p">][</span><span class="s2">&quot;gaps_finder&quot;</span><span class="p">][</span><span class="s2">&quot;gapsize_n&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># Create gaps and missing obs objects</span>
        <span class="c1"># self.gaps = gaps_list</span>
        <span class="c1"># self.missing_obs = Missingob_collection(missing_obs)</span>

        <span class="c1"># Perform QC checks on original observation frequencies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">dup_outl_df</span> <span class="o">=</span> <span class="n">duplicate_timestamp_check</span><span class="p">(</span>
            <span class="n">df</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span>
            <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">],</span>
            <span class="n">checks_settings</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">],</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">dup_outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_outliersdf</span><span class="p">(</span><span class="n">add_to_outliersdf</span><span class="o">=</span><span class="n">dup_outl_df</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">nan_outl_df</span> <span class="o">=</span> <span class="n">invalid_input_check</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">checks_info</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_checks_info&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">nan_outl_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_outliersdf</span><span class="p">(</span><span class="n">nan_outl_df</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">outliersdf</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="c1"># update the order and which qc is applied on which obstype</span>
        <span class="n">checked_obstypes</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">obs</span> <span class="k">for</span> <span class="n">obs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">obs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="n">checknames</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;duplicated_timestamp&quot;</span><span class="p">,</span> <span class="s2">&quot;invalid_input&quot;</span><span class="p">]</span>  <span class="c1"># KEEP order</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_applied_qc</span><span class="p">,</span>
                <span class="n">conv_applied_qc_to_df</span><span class="p">(</span>
                    <span class="n">obstypes</span><span class="o">=</span><span class="n">checked_obstypes</span><span class="p">,</span> <span class="n">ordered_checknames</span><span class="o">=</span><span class="n">checknames</span>
                <span class="p">),</span>
            <span class="p">],</span>
            <span class="n">ignore_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_setup_of_obstypes_and_units</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Function to setup all attributes related to observation types and</span>
<span class="sd">        convert to standard units.&quot;&quot;&quot;</span>

        <span class="c1"># Check if all present observation types are known.</span>
        <span class="n">unknown_obs_cols</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">obs_col</span>
            <span class="k">for</span> <span class="n">obs_col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
            <span class="k">if</span> <span class="n">obs_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unknown_obs_cols</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The following observation types are unknown: </span><span class="si">{</span><span class="n">unknown_obs_cols</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">obs_col</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
            <span class="c1"># Convert the units to the toolkit standards (if unit is known)</span>
            <span class="n">input_unit</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">,</span> <span class="n">obs_col</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span><span class="o">.</span><span class="n">convert_to_standard_units</span><span class="p">(</span>
                <span class="n">input_data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">obs_col</span><span class="p">],</span> <span class="n">input_unit</span><span class="o">=</span><span class="n">input_unit</span>
            <span class="p">)</span>

            <span class="c1"># Update the description of the obstype</span>
            <span class="n">description</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;description&quot;</span><span class="p">,</span> <span class="n">obs_col</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">pd</span><span class="o">.</span><span class="n">isna</span><span class="p">(</span><span class="n">description</span><span class="p">):</span>
                <span class="n">description</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span><span class="o">.</span><span class="n">set_description</span><span class="p">(</span><span class="n">desc</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

            <span class="c1"># Update the original column name and original units</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span><span class="o">.</span><span class="n">set_original_name</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;orig_name&quot;</span><span class="p">,</span> <span class="n">obs_col</span><span class="p">]</span>
            <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="p">[</span><span class="n">obs_col</span><span class="p">]</span><span class="o">.</span><span class="n">set_original_unit</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_template</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="s2">&quot;units&quot;</span><span class="p">,</span> <span class="n">obs_col</span><span class="p">]</span>
            <span class="p">)</span>

        <span class="c1"># subset the obstypes attribute</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">name</span><span class="p">:</span> <span class="n">obj</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">obstypes</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="p">}</span>

    <span class="c1"># =============================================================================</span>
    <span class="c1"># Physiography extractions</span>
    <span class="c1"># =============================================================================</span>
<div class="viewcode-block" id="Dataset.get_lcz">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_lcz.html#metobs_toolkit.Dataset.get_lcz">[docs]</a>
    <span class="k">def</span> <span class="nf">get_lcz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract local climate zones for all stations.</span>

<span class="sd">        Function to extract the Local CLimate zones (LCZ) from the</span>
<span class="sd">        wudapt global LCZ map on the Google engine for all stations.</span>

<span class="sd">        A &#39;LCZ&#39; column will be added to the metadf, and series is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        lcz_series : pandas.Series()</span>
<span class="sd">            A series with the stationnames as index and the LCZ as values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># connect to gee</span>
        <span class="n">connect_to_gee</span><span class="p">()</span>

        <span class="c1"># Extract LCZ for all stations</span>
        <span class="n">lcz_series</span> <span class="o">=</span> <span class="n">lcz_extractor</span><span class="p">(</span>
            <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
            <span class="n">mapinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gee</span><span class="p">[</span><span class="s2">&quot;gee_dataset_info&quot;</span><span class="p">][</span><span class="s2">&quot;global_lcz_map&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="c1"># drop column if it was already present</span>
        <span class="k">if</span> <span class="s2">&quot;lcz&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;lcz&quot;</span><span class="p">])</span>

        <span class="c1"># update metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">lcz_series</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(),</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">lcz_series</span></div>


<div class="viewcode-block" id="Dataset.get_altitude">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_altitude.html#metobs_toolkit.Dataset.get_altitude">[docs]</a>
    <span class="k">def</span> <span class="nf">get_altitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract Altitudes for all stations.</span>

<span class="sd">        Function to extract the Altitude from the SRTM Digital Elevation Data</span>
<span class="sd">        global map on the Google engine for all stations.</span>

<span class="sd">        A &#39;altitude&#39; column will be added to the metadf, and series is returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        altitude_series : pandas.Series()</span>
<span class="sd">            A series with the stationnames as index and the altitudes as values.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># connect to gee</span>
        <span class="n">connect_to_gee</span><span class="p">()</span>

        <span class="c1"># Extract LCZ for all stations</span>
        <span class="n">altitude_series</span> <span class="o">=</span> <span class="n">height_extractor</span><span class="p">(</span>
            <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span> <span class="n">mapinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gee</span><span class="p">[</span><span class="s2">&quot;gee_dataset_info&quot;</span><span class="p">][</span><span class="s2">&quot;DEM&quot;</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># drop column if it was already present</span>
        <span class="k">if</span> <span class="s2">&quot;altitude&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;altitude&quot;</span><span class="p">])</span>

        <span class="c1"># update metadata</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span>
            <span class="n">altitude_series</span><span class="o">.</span><span class="n">to_frame</span><span class="p">(),</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="n">left_index</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right_index</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">altitude_series</span></div>


<div class="viewcode-block" id="Dataset.get_landcover">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.get_landcover.html#metobs_toolkit.Dataset.get_landcover">[docs]</a>
    <span class="k">def</span> <span class="nf">get_landcover</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">buffers</span><span class="o">=</span><span class="p">[</span><span class="mi">100</span><span class="p">],</span> <span class="n">aggregate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gee_map</span><span class="o">=</span><span class="s2">&quot;worldcover&quot;</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Extract landcover for all stations.</span>

<span class="sd">        Extract the landcover fractions in a buffer with a specific radius for</span>
<span class="sd">        all stations. If an aggregation scheme is define, one can choose to</span>
<span class="sd">        aggregate the landcoverclasses.</span>

<span class="sd">        The landcover fractions will be added to the Dataset.metadf if overwrite</span>
<span class="sd">        is True. Presented as seperate columns where each column represent the</span>
<span class="sd">        landcovertype and corresponding buffer.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        buffers : num, optional</span>
<span class="sd">            The list of buffer radia in dataset units (meters for ESA worldcover) . The default is 100.</span>
<span class="sd">        aggregate : bool, optional</span>
<span class="sd">            If True, the classes will be aggregated with the corresponding</span>
<span class="sd">            aggregation scheme. The default is True.</span>
<span class="sd">        overwrite : bool, optional</span>
<span class="sd">            If True, the Datset.metadf will be updated with the generated</span>
<span class="sd">            landcoverfractions. The default is True.</span>
<span class="sd">        gee_map : str, optional</span>
<span class="sd">            The name of the dataset to use. This name should be present in the</span>
<span class="sd">            settings.gee[&#39;gee_dataset_info&#39;]. If aggregat is True, an aggregation</span>
<span class="sd">            scheme should included as well. The default is &#39;worldcover&#39;</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frac_df : pandas.DataFrame</span>
<span class="sd">            A Dataframe with index: name, buffer_radius and the columns are the</span>
<span class="sd">            fractions.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># connect to gee</span>
        <span class="n">connect_to_gee</span><span class="p">()</span>

        <span class="n">df_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">buffer</span> <span class="ow">in</span> <span class="n">buffers</span><span class="p">:</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Extracting landcover from </span><span class="si">{</span><span class="n">gee_map</span><span class="si">}</span><span class="s2"> with buffer radius = </span><span class="si">{</span><span class="n">buffer</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="c1"># Extract landcover fractions for all stations</span>
            <span class="n">lc_frac_df</span><span class="p">,</span> <span class="n">buffer</span> <span class="o">=</span> <span class="n">lc_fractions_extractor</span><span class="p">(</span>
                <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">,</span>
                <span class="n">mapinfo</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gee</span><span class="p">[</span><span class="s2">&quot;gee_dataset_info&quot;</span><span class="p">][</span><span class="n">gee_map</span><span class="p">],</span>
                <span class="n">buffer</span><span class="o">=</span><span class="n">buffer</span><span class="p">,</span>
                <span class="n">agg</span><span class="o">=</span><span class="n">aggregate</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="c1"># add buffer to the index</span>
            <span class="n">lc_frac_df</span><span class="p">[</span><span class="s2">&quot;buffer_radius&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">buffer</span>
            <span class="n">lc_frac_df</span> <span class="o">=</span> <span class="n">lc_frac_df</span><span class="o">.</span><span class="n">reset_index</span><span class="p">()</span><span class="o">.</span><span class="n">set_index</span><span class="p">([</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;buffer_radius&quot;</span><span class="p">])</span>
            <span class="n">lc_frac_df</span> <span class="o">=</span> <span class="n">lc_frac_df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

            <span class="c1"># add to the list</span>
            <span class="n">df_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lc_frac_df</span><span class="p">)</span>

        <span class="c1"># concat all df for different buffers to one</span>
        <span class="n">frac_df</span> <span class="o">=</span> <span class="n">concat_save</span><span class="p">(</span><span class="n">df_list</span><span class="p">)</span>
        <span class="n">frac_df</span> <span class="o">=</span> <span class="n">frac_df</span><span class="o">.</span><span class="n">sort_index</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">buf</span> <span class="ow">in</span> <span class="n">frac_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_level_values</span><span class="p">(</span><span class="s2">&quot;buffer_radius&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">unique</span><span class="p">():</span>
                <span class="n">buf_df</span> <span class="o">=</span> <span class="n">xs_save</span><span class="p">(</span><span class="n">frac_df</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="s2">&quot;buffer_radius&quot;</span><span class="p">)</span>
                <span class="n">buf_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="nb">int</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span><span class="si">}</span><span class="s2">m&quot;</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">buf_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>

                <span class="c1"># overwrite the columns or add them if they did not exist</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">[</span><span class="n">buf_df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf_df</span>

        <span class="k">return</span> <span class="n">frac_df</span></div>


<div class="viewcode-block" id="Dataset.make_gee_plot">
<a class="viewcode-back" href="../../reference/api/metobs_toolkit.Dataset.make_gee_plot.html#metobs_toolkit.Dataset.make_gee_plot">[docs]</a>
    <span class="k">def</span> <span class="nf">make_gee_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">gee_map</span><span class="p">,</span> <span class="n">show_stations</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">outputfile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make an interactive plot of a google earth dataset.</span>

<span class="sd">        The location of the stations can be plotted on top of it.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        gee_map : str, optional</span>
<span class="sd">            The name of the dataset to use. This name should be present in the</span>
<span class="sd">            settings.gee[&#39;gee_dataset_info&#39;]. If aggregat is True, an aggregation</span>
<span class="sd">            scheme should included as well. The default is &#39;worldcover&#39;</span>
<span class="sd">        show_stations : bool, optional</span>
<span class="sd">            If True, the stations will be plotted as markers. The default is True.</span>
<span class="sd">        save : bool, optional</span>
<span class="sd">            If True, the map will be saved as an html file in the output_folder</span>
<span class="sd">            as defined in the settings if the outputfile is not set. The</span>
<span class="sd">            default is False.</span>
<span class="sd">        outputfile : str, optional</span>
<span class="sd">            Specify the path of the html file if save is True. If None, and save</span>
<span class="sd">            is true, the html file will be saved in the output_folder. The</span>
<span class="sd">            default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Map : geemap.foliumap.Map</span>
<span class="sd">            The folium Map instance.</span>


<span class="sd">        Warning</span>
<span class="sd">        ---------</span>
<span class="sd">        To display the interactive map a graphical backend is required, which</span>
<span class="sd">        is often missing on (free) cloud platforms. Therefore it is better to</span>
<span class="sd">        set save=True, and open the .html in your browser</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Connect to GEE</span>
        <span class="n">connect_to_gee</span><span class="p">()</span>

        <span class="c1"># get the mapinfo</span>
        <span class="n">mapinfo</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">gee</span><span class="p">[</span><span class="s2">&quot;gee_dataset_info&quot;</span><span class="p">][</span><span class="n">gee_map</span><span class="p">]</span>

        <span class="c1"># Read in covers, numbers and labels</span>
        <span class="n">covernum</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapinfo</span><span class="p">[</span><span class="s2">&quot;colorscheme&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mapinfo</span><span class="p">[</span><span class="s2">&quot;colorscheme&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">covername</span> <span class="o">=</span> <span class="p">[</span><span class="n">mapinfo</span><span class="p">[</span><span class="s2">&quot;categorical_mapper&quot;</span><span class="p">][</span><span class="n">covnum</span><span class="p">]</span> <span class="k">for</span> <span class="n">covnum</span> <span class="ow">in</span> <span class="n">covernum</span><span class="p">]</span>

        <span class="c1"># create visparams</span>
        <span class="n">vis_params</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;min&quot;</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">covernum</span><span class="p">),</span>
            <span class="s2">&quot;max&quot;</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">covernum</span><span class="p">),</span>
            <span class="s2">&quot;palette&quot;</span><span class="p">:</span> <span class="n">colors</span><span class="p">,</span>  <span class="c1"># hex colors!</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="s2">&quot;band_of_use&quot;</span> <span class="ow">in</span> <span class="n">mapinfo</span><span class="p">:</span>
            <span class="n">band</span> <span class="o">=</span> <span class="n">mapinfo</span><span class="p">[</span><span class="s2">&quot;band_of_use&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">band</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">Map</span> <span class="o">=</span> <span class="n">folium_plot</span><span class="p">(</span>
            <span class="n">mapinfo</span><span class="o">=</span><span class="n">mapinfo</span><span class="p">,</span>
            <span class="n">band</span><span class="o">=</span><span class="n">band</span><span class="p">,</span>
            <span class="n">vis_params</span><span class="o">=</span><span class="n">vis_params</span><span class="p">,</span>
            <span class="n">labelnames</span><span class="o">=</span><span class="n">covername</span><span class="p">,</span>
            <span class="n">layername</span><span class="o">=</span><span class="n">gee_map</span><span class="p">,</span>
            <span class="n">legendname</span><span class="o">=</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gee_map</span><span class="si">}</span><span class="s2"> covers&quot;</span><span class="p">,</span>
            <span class="c1"># showmap = show,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">show_stations</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">_validate_metadf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Not enough coordinates information is provided to plot the stations.&quot;</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Map</span> <span class="o">=</span> <span class="n">add_stations_to_folium_map</span><span class="p">(</span><span class="n">Map</span><span class="o">=</span><span class="n">Map</span><span class="p">,</span> <span class="n">metadf</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">metadf</span><span class="p">)</span>

        <span class="c1"># Save if needed</span>
        <span class="k">if</span> <span class="n">save</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">outputfile</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Try to save in the output folder</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;The outputfolder is not set up, use the update_settings to specify the output_folder.&quot;</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="n">filename</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;gee_</span><span class="si">{</span><span class="n">gee_map</span><span class="si">}</span><span class="s2">_figure.html&quot;</span>
                    <span class="n">filepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">IO</span><span class="p">[</span><span class="s2">&quot;output_folder&quot;</span><span class="p">],</span> <span class="n">filename</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># outputfile is specified</span>
                <span class="c1"># 1. check extension</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">outputfile</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;.html&quot;</span><span class="p">):</span>
                    <span class="n">outputfile</span> <span class="o">=</span> <span class="n">outputfile</span> <span class="o">+</span> <span class="s2">&quot;.html&quot;</span>

                <span class="n">filepath</span> <span class="o">=</span> <span class="n">outputfile</span>

            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gee Map will be save at </span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Gee Map will be save at </span><span class="si">{</span><span class="n">filepath</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">Map</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">filepath</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Map</span></div>



<span class="k">def</span> <span class="nf">_can_qc_be_applied</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">obstype</span><span class="p">,</span> <span class="n">checkname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Test if a qc check can be applied.&quot;&quot;&quot;</span>
    <span class="c1"># test if check is already applied on the obstype</span>
    <span class="n">applied_df</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">_applied_qc</span>
    <span class="n">can_be_applied</span> <span class="o">=</span> <span class="p">(</span>
        <span class="ow">not</span> <span class="n">applied_df</span><span class="p">[</span>
            <span class="p">(</span><span class="n">applied_df</span><span class="p">[</span><span class="s2">&quot;obstype&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">obstype</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">applied_df</span><span class="p">[</span><span class="s2">&quot;checkname&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">checkname</span><span class="p">)</span>
        <span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">can_be_applied</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> check can NOT be applied on </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> because it was already applied on this observation type!&quot;</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="kc">False</span>
    <span class="c1"># test of all settings are present for the check on the obstype</span>
    <span class="k">if</span> <span class="n">checkname</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span>
        <span class="s2">&quot;duplicated_timestamp&quot;</span><span class="p">,</span>
        <span class="s2">&quot;titan_buddy_check&quot;</span><span class="p">,</span>
        <span class="s2">&quot;titan_sct_resistant_check&quot;</span><span class="p">,</span>
    <span class="p">]:</span>
        <span class="c1"># these checks are obstype depending,</span>
        <span class="n">required_keys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="n">dataset</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span><span class="s2">&quot;temp&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="p">)</span>  <span class="c1"># use temp to find all required settings</span>
        <span class="k">if</span> <span class="n">obstype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> check can NOT be applied on </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> because none of the required check settings are found. The following are missing: </span><span class="si">{</span><span class="n">required_keys</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">req_key</span>
                <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span><span class="n">obstype</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">req_key</span> <span class="ow">in</span> <span class="n">required_keys</span>
            <span class="p">]</span>
        <span class="p">):</span>
            <span class="c1"># not all required settings are available</span>
            <span class="n">missing_settings</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">req_key</span>
                <span class="k">for</span> <span class="n">req_key</span> <span class="ow">in</span> <span class="n">required_keys</span>
                <span class="k">if</span> <span class="n">req_key</span>
                <span class="ow">not</span> <span class="ow">in</span> <span class="n">dataset</span><span class="o">.</span><span class="n">settings</span><span class="o">.</span><span class="n">qc</span><span class="p">[</span><span class="s2">&quot;qc_check_settings&quot;</span><span class="p">][</span><span class="n">checkname</span><span class="p">][</span>
                    <span class="n">obstype</span>
                <span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
            <span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The </span><span class="si">{</span><span class="n">checkname</span><span class="si">}</span><span class="s2"> check can NOT be applied on </span><span class="si">{</span><span class="n">obstype</span><span class="si">}</span><span class="s2"> because not all required check settings ar found. The following are missing: </span><span class="si">{</span><span class="n">missing_settings</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">return</span> <span class="kc">True</span>
</pre></div>

                </article>





                <footer class="prev-next-footer">

<div class="prev-next-area">
</div>
                </footer>

            </div>



                <div class="bd-sidebar-secondary bd-toc"></div>


          </div>
          <footer class="bd-footer-content">

          </footer>

      </main>
    </div>
  </div>

  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../../_static/scripts/bootstrap.js?digest=8d27b9dea8ad943066ae"></script>
<script src="../../_static/scripts/pydata-sphinx-theme.js?digest=8d27b9dea8ad943066ae"></script>

  <footer class="bd-footer">
<div class="bd-footer__inner bd-page-width">

    <div class="footer-items__start">

        <div class="footer-item">

  <p class="copyright">

       Copyright 2023, Thomas Vergauwen.
      <br/>

  </p>
</div>

        <div class="footer-item">

  <p class="sphinx-version">
    Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 7.2.6.
    <br/>
  </p>
</div>

    </div>



    <div class="footer-items__end">

        <div class="footer-item">
<p class="theme-version">
  Built with the <a href="https://pydata-sphinx-theme.readthedocs.io/en/stable/index.html">PyData Sphinx Theme</a> 0.15.2.
</p></div>

    </div>

</div>

  </footer>
  </body>
</html>
